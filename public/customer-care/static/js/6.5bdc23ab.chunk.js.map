{"version":3,"sources":["../node_modules/intl/index.js","../node_modules/intl/lib/core.js"],"names":["global","IntlPolyfill","Intl","__applyLocaleSensitivePrototypes","module","exports","_typeof","Symbol","iterator","obj","constructor","jsx","REACT_ELEMENT_TYPE","for","type","props","key","children","defaultProps","childrenLength","arguments","length","propName","childArray","Array","i","$$typeof","undefined","ref","_owner","createClass","defineProperties","target","descriptor","enumerable","configurable","writable","Object","defineProperty","Constructor","protoProps","staticProps","prototype","defineProperty$1","value","_extends","assign","source","hasOwnProperty","call","selfGlobal","self","slicedToArray","arr","isArray","_arr","_n","_d","_e","_s","_i","next","done","push","err","sliceIterator","TypeError","babelHelpers$1","freeze","asyncToGenerator","fn","gen","apply","this","Promise","resolve","reject","step","arg","info","error","then","classCallCheck","instance","defineEnumerableProperties","descs","desc","defaults","_defaults","keys","getOwnPropertyNames","getOwnPropertyDescriptor","get","object","property","receiver","Function","parent","getPrototypeOf","getter","inherits","subClass","superClass","create","setPrototypeOf","__proto__","interopRequireDefault","__esModule","default","interopRequireWildcard","newObj","newArrowCheck","innerThis","boundThis","objectDestructuringEmpty","objectWithoutProperties","indexOf","possibleConstructorReturn","ReferenceError","set","setter","slicedToArrayLoose","_step","_iterator","taggedTemplateLiteral","strings","raw","taggedTemplateLiteralLoose","temporalRef","val","name","undef","temporalUndefined","toArray","from","toConsumableArray","arr2","typeof","extends","instanceof","left","right","hasInstance","realDefineProp","sentinel","a","e","es3","__defineGetter__","hop","arrIndexOf","search","t","max","objCreate","proto","F","k","arrSlice","slice","arrConcat","concat","arrPush","arrJoin","join","arrShift","shift","fnBind","bind","thisObj","args","internals","secret","Math","random","Record","List","createRegExpRestore","disableRegExpRestore","regExpCache","lastMatch","RegExp","leftContext","multiline","input","has","esc","lm","replace","reg","m","exprStr","match","expr","lastIndex","exec","toObject","toNumber","Number","toLength","len","number","isNaN","Infinity","floor","abs","toInteger","pow","min","getInternalProperties","__getInternalProperties","variant","extension","singleton","expBCP47Syntax","expVariantDupes","expSingletonDupes","expExtSequences","defaultLocale","redundantTags","tags","subtags","BU","DD","FX","TP","YD","ZR","heploc","iw","ji","jw","mo","ayx","bjd","ccq","cjr","cka","cmk","drh","drw","gav","hrr","ibi","kgh","lcq","mst","myt","sca","tie","tkk","tlw","tnf","ybd","yma","extLang","aao","abh","abv","acm","acq","acw","acx","acy","adf","ads","aeb","aec","aed","aen","afb","afg","ajp","apc","apd","arb","arq","ars","ary","arz","ase","asf","asp","asq","asw","auz","avl","ayh","ayl","ayn","ayp","bbz","bfi","bfk","bjn","bog","bqn","bqy","btj","bve","bvl","bvu","bzs","cdo","cds","cjy","cmn","coa","cpx","csc","csd","cse","csf","csg","csl","csn","csq","csr","czh","czo","doq","dse","dsl","dup","ecs","esl","esn","eso","eth","fcs","fse","fsl","fss","gan","gds","gom","gse","gsg","gsm","gss","gus","hab","haf","hak","hds","hji","hks","hos","hps","hsh","hsl","hsn","icl","ils","inl","ins","ise","isg","isr","jak","jax","jcs","jhs","jls","jos","jsl","jus","kgi","knn","kvb","kvk","kvr","kxd","lbs","lce","lcf","liw","lls","lsg","lsl","lso","lsp","lst","lsy","ltg","lvs","lzh","mdl","meo","mfa","mfb","mfs","mnp","mqg","mre","msd","msi","msr","mui","mzc","mzg","mzy","nan","nbs","ncs","nsi","nsl","nsp","nsr","nzs","okl","orn","ors","pel","pga","pks","prl","prz","psc","psd","pse","psg","psl","pso","psp","psr","pys","rms","rsi","rsl","sdl","sfb","sfs","sgg","sgx","shu","slf","sls","sqk","sqs","ssh","ssp","ssr","svk","swc","swh","swl","syy","tmw","tse","tsm","tsq","tss","tsy","tza","ugn","ugy","ukl","uks","urk","uzn","uzs","vgt","vkk","vkt","vsi","vsl","vsv","wuu","xki","xml","xmm","xms","yds","ysl","yue","zib","zlm","zmi","zsl","zsm","toLatinUpperCase","str","ch","charAt","toUpperCase","IsStructurallyValidLanguageTag","locale","test","CanonicalizeLanguageTag","parts","toLowerCase","split","sort","_max","expCurrencyCode","expUnicodeExSeq","CanonicalizeLocaleList","locales","seen","O","Pk","String","kValue","tag","RangeError","BestAvailableLocale","availableLocales","candidate","pos","lastIndexOf","substring","LookupMatcher","requestedLocales","availableLocale","noExtensionsLocale","result","extensionIndex","ResolveLocale","options","relevantExtensionKeys","localeData","r","foundLocale","BestFitMatcher","extensionSubtags","extensionSubtagsLength","supportedExtension","keyLocaleData","supportedExtensionAddition","keyPos","requestedValue","optionsValue","privateIndex","preExtension","postExtension","LookupSupportedLocales","subset","SupportedLocales","matcher","localeMatcher","P","BestFitSupportedLocales","GetOption","values","fallback","Boolean","GetNumberOption","minimum","maximum","ll","currencyMinorUnits","BHD","BYR","XOF","BIF","XAF","CLF","CLP","KMF","DJF","XPF","GNF","ISK","IQD","JPY","JOD","KRW","KWD","LYD","OMR","PYG","RWF","TND","UGX","UYI","VUV","VND","NumberFormatConstructor","numberFormat","internal","regexpRestore","opt","NumberFormat","dataLocale","s","c","currency","normalized","IsWellFormedCurrencyCode","cDigits","cd","mnid","mnfd","mxfdDefault","mxfd","mnsd","minimumSignificantDigits","mxsd","maximumSignificantDigits","g","stylePatterns","patterns","positivePattern","negativePattern","format","GetFormatNumber","InitializeNumberFormat","bf","FormatNumber","PartitionNumberPattern","x","nums","data","ild","symbols","latn","pattern","beginIndex","endIndex","nextIndex","Error","literal","p","n","isFinite","_n2","ToRawPrecision","ToRawFixed","numSys","digits","digit","integer","fraction","decimalSepIndex","groupSepSymbol","group","groups","pgSize","primaryGroupSize","sgSize","secondaryGroupSize","end","idx","start","integerGroup","decimalSepSymbol","decimal","infinity","plusSignSymbol","plusSign","minusSignSymbol","minusSign","percentSignSymbol","percentSign","currencies","_literal","_literal2","minPrecision","maxPrecision","log10","round","log","LOG10E","log10Floor","f","exp","LN10","cut","minInteger","minFraction","maxFraction","toFixed","_int","b","part","FormatNumberToParts","arab","arabext","bali","beng","deva","fullwide","gujr","guru","hanidec","khmr","knda","laoo","limb","mlym","mong","mymr","orya","tamldec","telu","thai","tibt","prop","expDTComponents","expPatternTrimmer","unwantedDTCs","dtKeys","tmKeys","isDateFormatOnly","isTimeFormatOnly","joinDateAndTimeFormats","dateFormatObj","timeFormatObj","o","_","j","computeFinalPatterns","formatObj","pattern12","extendedPattern","$0","expDTComponentsMeta","era","year","quarter","month","week","day","weekday","hour12","hour","minute","second","timeZoneName","createDateTimeFormat","skeleton","originalPattern","validSyntheticProps","numeric","narrow","short","long","dateWidths","resolveDateString","ca","component","width","gregory","alts","resolved","DateTimeFormatConstructor","dateTimeFormat","ToDateTimeOptions","DateTimeFormat","tz","timeZone","dateTimeComponents","bestFormat","dataLocaleData","formats","toString","availableFormats","timeFormats","dateFormats","computed","timeRelatedFormats","dateRelatedFormats","full","medium","createDateTimeFormats","ToDateTimeFormats","bestScore","score","optionsProp","formatProp","optionsPropIndex","formatPropIndex","delta","BasicFormatMatcher","_hr","optionsPropNames","_bestFormat","propValue","_ref2","generateSyntheticFormat","_property","patternProp","BestFitFormatMatcher","_prop","hr12","hourNo0","GetFormatDateTime","InitializeDateTimeFormat","required","opt2","needDefaults","date","Date","now","FormatDateTime","CreateDateTimeParts","nf","useGrouping","nf2","minimumIntegerDigits","tm","calendar","d","ToLocalTime","index","calendars","fv","v","substr","FormatToPartsDateTime","ls","__localeSensitiveProtos","toLocaleString","toLocaleDateString","toLocaleTimeString","nu","setDefaultLocale","addLocaleData"],"mappings":"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C,IAAK,CAAC,MAAO,MACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,MACbC,IAAK,CAAC,MAAO,MACbC,IAAK,CAAC,MAAO,MACbC,IAAK,CAAC,MAAO,MACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,MACbC,IAAK,CAAC,MAAO,MACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,MACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,MACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,MACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,MACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,MACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,MACbC,IAAK,CAAC,MAAO,MACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,MACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,MACbC,IAAK,CAAC,MAAO,MACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,MACbC,IAAK,CAAC,MAAO,MACbC,IAAK,CAAC,MAAO,MACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,MACbC,IAAK,CAAC,MAAO,MACbC,IAAK,CAAC,MAAO,MACbzO,IAAK,CAAC,MAAO,MACb0O,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,MACbC,IAAK,CAAC,MAAO,MACbC,IAAK,CAAC,MAAO,MACbC,IAAK,CAAC,MAAO,OACbvL,IAAK,CAAC,MAAO,MACbwL,IAAK,CAAC,MAAO,MACbC,IAAK,CAAC,MAAO,MACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,MACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,MACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,MACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,MACbC,IAAK,CAAC,MAAO,MACbC,IAAK,CAAC,MAAO,MACbC,IAAK,CAAC,MAAO,MACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,MACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,MACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,MACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,MACbC,IAAK,CAAC,MAAO,MACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,MACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,MACbC,IAAK,CAAC,MAAO,MACbC,IAAK,CAAC,MAAO,MACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,MACbC,IAAK,CAAC,MAAO,MACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,MACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,OACbC,IAAK,CAAC,MAAO,MACbC,IAA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","file":"static/js/6.5bdc23ab.chunk.js","sourcesContent":["// Expose `IntlPolyfill` as global to add locale data into runtime later on.\nglobal.IntlPolyfill = require('./lib/core.js'); // Require all locale data for `Intl`. This module will be\n// ignored when bundling for the browser with Browserify/Webpack.\n\nrequire('./locale-data/complete.js'); // hack to export the polyfill as global Intl if needed\n\n\nif (!global.Intl) {\n  global.Intl = global.IntlPolyfill;\n\n  global.IntlPolyfill.__applyLocaleSensitivePrototypes();\n} // providing an idiomatic api for the nodejs version of this module\n\n\nmodule.exports = global.IntlPolyfill;","'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj;\n};\n\nvar jsx = function () {\n  var REACT_ELEMENT_TYPE = typeof Symbol === \"function\" && Symbol.for && Symbol.for(\"react.element\") || 0xeac7;\n  return function createRawReactElement(type, props, key, children) {\n    var defaultProps = type && type.defaultProps;\n    var childrenLength = arguments.length - 3;\n\n    if (!props && childrenLength !== 0) {\n      props = {};\n    }\n\n    if (props && defaultProps) {\n      for (var propName in defaultProps) {\n        if (props[propName] === void 0) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    } else if (!props) {\n      props = defaultProps || {};\n    }\n\n    if (childrenLength === 1) {\n      props.children = children;\n    } else if (childrenLength > 1) {\n      var childArray = Array(childrenLength);\n\n      for (var i = 0; i < childrenLength; i++) {\n        childArray[i] = arguments[i + 3];\n      }\n\n      props.children = childArray;\n    }\n\n    return {\n      $$typeof: REACT_ELEMENT_TYPE,\n      type: type,\n      key: key === undefined ? null : '' + key,\n      ref: null,\n      props: props,\n      _owner: null\n    };\n  };\n}();\n\nvar asyncToGenerator = function asyncToGenerator(fn) {\n  return function () {\n    var gen = fn.apply(this, arguments);\n    return new Promise(function (resolve, reject) {\n      function step(key, arg) {\n        try {\n          var info = gen[key](arg);\n          var value = info.value;\n        } catch (error) {\n          reject(error);\n          return;\n        }\n\n        if (info.done) {\n          resolve(value);\n        } else {\n          return Promise.resolve(value).then(function (value) {\n            return step(\"next\", value);\n          }, function (err) {\n            return step(\"throw\", err);\n          });\n        }\n      }\n\n      return step(\"next\");\n    });\n  };\n};\n\nvar classCallCheck = function classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar defineEnumerableProperties = function defineEnumerableProperties(obj, descs) {\n  for (var key in descs) {\n    var desc = descs[key];\n    desc.configurable = desc.enumerable = true;\n    if (\"value\" in desc) desc.writable = true;\n    Object.defineProperty(obj, key, desc);\n  }\n\n  return obj;\n};\n\nvar defaults = function defaults(obj, _defaults) {\n  var keys = Object.getOwnPropertyNames(_defaults);\n\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    var value = Object.getOwnPropertyDescriptor(_defaults, key);\n\n    if (value && value.configurable && obj[key] === undefined) {\n      Object.defineProperty(obj, key, value);\n    }\n  }\n\n  return obj;\n};\n\nvar defineProperty$1 = function defineProperty$1(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n};\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar get = function get(object, property, receiver) {\n  if (object === null) object = Function.prototype;\n  var desc = Object.getOwnPropertyDescriptor(object, property);\n\n  if (desc === undefined) {\n    var parent = Object.getPrototypeOf(object);\n\n    if (parent === null) {\n      return undefined;\n    } else {\n      return get(parent, property, receiver);\n    }\n  } else if (\"value\" in desc) {\n    return desc.value;\n  } else {\n    var getter = desc.get;\n\n    if (getter === undefined) {\n      return undefined;\n    }\n\n    return getter.call(receiver);\n  }\n};\n\nvar inherits = function inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\nvar _instanceof = function _instanceof(left, right) {\n  if (right != null && typeof Symbol !== \"undefined\" && right[Symbol.hasInstance]) {\n    return right[Symbol.hasInstance](left);\n  } else {\n    return left instanceof right;\n  }\n};\n\nvar interopRequireDefault = function interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n};\n\nvar interopRequireWildcard = function interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n};\n\nvar newArrowCheck = function newArrowCheck(innerThis, boundThis) {\n  if (innerThis !== boundThis) {\n    throw new TypeError(\"Cannot instantiate an arrow function\");\n  }\n};\n\nvar objectDestructuringEmpty = function objectDestructuringEmpty(obj) {\n  if (obj == null) throw new TypeError(\"Cannot destructure undefined\");\n};\n\nvar objectWithoutProperties = function objectWithoutProperties(obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n};\n\nvar possibleConstructorReturn = function possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\nvar selfGlobal = typeof global === \"undefined\" ? self : global;\n\nvar set = function set(object, property, value, receiver) {\n  var desc = Object.getOwnPropertyDescriptor(object, property);\n\n  if (desc === undefined) {\n    var parent = Object.getPrototypeOf(object);\n\n    if (parent !== null) {\n      set(parent, property, value, receiver);\n    }\n  } else if (\"value\" in desc && desc.writable) {\n    desc.value = value;\n  } else {\n    var setter = desc.set;\n\n    if (setter !== undefined) {\n      setter.call(receiver, value);\n    }\n  }\n\n  return value;\n};\n\nvar slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar slicedToArrayLoose = function slicedToArrayLoose(arr, i) {\n  if (Array.isArray(arr)) {\n    return arr;\n  } else if (Symbol.iterator in Object(arr)) {\n    var _arr = [];\n\n    for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {\n      _arr.push(_step.value);\n\n      if (i && _arr.length === i) break;\n    }\n\n    return _arr;\n  } else {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n  }\n};\n\nvar taggedTemplateLiteral = function taggedTemplateLiteral(strings, raw) {\n  return Object.freeze(Object.defineProperties(strings, {\n    raw: {\n      value: Object.freeze(raw)\n    }\n  }));\n};\n\nvar taggedTemplateLiteralLoose = function taggedTemplateLiteralLoose(strings, raw) {\n  strings.raw = raw;\n  return strings;\n};\n\nvar temporalRef = function temporalRef(val, name, undef) {\n  if (val === undef) {\n    throw new ReferenceError(name + \" is not defined - temporal dead zone\");\n  } else {\n    return val;\n  }\n};\n\nvar temporalUndefined = {};\n\nvar toArray = function toArray(arr) {\n  return Array.isArray(arr) ? arr : Array.from(arr);\n};\n\nvar toConsumableArray = function toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n\nvar babelHelpers$1 = Object.freeze({\n  jsx: jsx,\n  asyncToGenerator: asyncToGenerator,\n  classCallCheck: classCallCheck,\n  createClass: createClass,\n  defineEnumerableProperties: defineEnumerableProperties,\n  defaults: defaults,\n  defineProperty: defineProperty$1,\n  get: get,\n  inherits: inherits,\n  interopRequireDefault: interopRequireDefault,\n  interopRequireWildcard: interopRequireWildcard,\n  newArrowCheck: newArrowCheck,\n  objectDestructuringEmpty: objectDestructuringEmpty,\n  objectWithoutProperties: objectWithoutProperties,\n  possibleConstructorReturn: possibleConstructorReturn,\n  selfGlobal: selfGlobal,\n  set: set,\n  slicedToArray: slicedToArray,\n  slicedToArrayLoose: slicedToArrayLoose,\n  taggedTemplateLiteral: taggedTemplateLiteral,\n  taggedTemplateLiteralLoose: taggedTemplateLiteralLoose,\n  temporalRef: temporalRef,\n  temporalUndefined: temporalUndefined,\n  toArray: toArray,\n  toConsumableArray: toConsumableArray,\n  typeof: _typeof,\n  extends: _extends,\n  instanceof: _instanceof\n});\n\nvar realDefineProp = function () {\n  var sentinel = function sentinel() {};\n\n  try {\n    Object.defineProperty(sentinel, 'a', {\n      get: function get() {\n        return 1;\n      }\n    });\n    Object.defineProperty(sentinel, 'prototype', {\n      writable: false\n    });\n    return sentinel.a === 1 && sentinel.prototype instanceof Object;\n  } catch (e) {\n    return false;\n  }\n}(); // Need a workaround for getters in ES3\n\n\nvar es3 = !realDefineProp && !Object.prototype.__defineGetter__; // We use this a lot (and need it for proto-less objects)\n\nvar hop = Object.prototype.hasOwnProperty; // Naive defineProperty for compatibility\n\nvar defineProperty = realDefineProp ? Object.defineProperty : function (obj, name, desc) {\n  if ('get' in desc && obj.__defineGetter__) obj.__defineGetter__(name, desc.get);else if (!hop.call(obj, name) || 'value' in desc) obj[name] = desc.value;\n}; // Array.prototype.indexOf, as good as we need it to be\n\nvar arrIndexOf = Array.prototype.indexOf || function (search) {\n  /*jshint validthis:true */\n  var t = this;\n  if (!t.length) return -1;\n\n  for (var i = arguments[1] || 0, max = t.length; i < max; i++) {\n    if (t[i] === search) return i;\n  }\n\n  return -1;\n}; // Create an object with the specified prototype (2nd arg required for Record)\n\n\nvar objCreate = Object.create || function (proto, props) {\n  var obj = void 0;\n\n  function F() {}\n\n  F.prototype = proto;\n  obj = new F();\n\n  for (var k in props) {\n    if (hop.call(props, k)) defineProperty(obj, k, props[k]);\n  }\n\n  return obj;\n}; // Snapshot some (hopefully still) native built-ins\n\n\nvar arrSlice = Array.prototype.slice;\nvar arrConcat = Array.prototype.concat;\nvar arrPush = Array.prototype.push;\nvar arrJoin = Array.prototype.join;\nvar arrShift = Array.prototype.shift; // Naive Function.prototype.bind for compatibility\n\nvar fnBind = Function.prototype.bind || function (thisObj) {\n  var fn = this,\n      args = arrSlice.call(arguments, 1); // All our (presently) bound functions have either 1 or 0 arguments. By returning\n  // different function signatures, we can pass some tests in ES3 environments\n\n  if (fn.length === 1) {\n    return function () {\n      return fn.apply(thisObj, arrConcat.call(args, arrSlice.call(arguments)));\n    };\n  }\n\n  return function () {\n    return fn.apply(thisObj, arrConcat.call(args, arrSlice.call(arguments)));\n  };\n}; // Object housing internal properties for constructors\n\n\nvar internals = objCreate(null); // Keep internal properties internal\n\nvar secret = Math.random(); // Helper functions\n// ================\n\n/**\n * A function to deal with the inaccuracy of calculating log10 in pre-ES6\n * JavaScript environments. Math.log(num) / Math.LN10 was responsible for\n * causing issue #62.\n */\n\nfunction log10Floor(n) {\n  // ES6 provides the more accurate Math.log10\n  if (typeof Math.log10 === 'function') return Math.floor(Math.log10(n));\n  var x = Math.round(Math.log(n) * Math.LOG10E);\n  return x - (Number('1e' + x) > n);\n}\n/**\n * A map that doesn't contain Object in its prototype chain\n */\n\n\nfunction Record(obj) {\n  // Copy only own properties over unless this object is already a Record instance\n  for (var k in obj) {\n    if (obj instanceof Record || hop.call(obj, k)) defineProperty(this, k, {\n      value: obj[k],\n      enumerable: true,\n      writable: true,\n      configurable: true\n    });\n  }\n}\n\nRecord.prototype = objCreate(null);\n/**\n * An ordered list\n */\n\nfunction List() {\n  defineProperty(this, 'length', {\n    writable: true,\n    value: 0\n  });\n  if (arguments.length) arrPush.apply(this, arrSlice.call(arguments));\n}\n\nList.prototype = objCreate(null);\n/**\n * Constructs a regular expression to restore tainted RegExp properties\n */\n\nfunction createRegExpRestore() {\n  if (internals.disableRegExpRestore) {\n    return function () {\n      /* no-op */\n    };\n  }\n\n  var regExpCache = {\n    lastMatch: RegExp.lastMatch || '',\n    leftContext: RegExp.leftContext,\n    multiline: RegExp.multiline,\n    input: RegExp.input\n  },\n      has = false; // Create a snapshot of all the 'captured' properties\n\n  for (var i = 1; i <= 9; i++) {\n    has = (regExpCache['$' + i] = RegExp['$' + i]) || has;\n  }\n\n  return function () {\n    // Now we've snapshotted some properties, escape the lastMatch string\n    var esc = /[.?*+^$[\\]\\\\(){}|-]/g,\n        lm = regExpCache.lastMatch.replace(esc, '\\\\$&'),\n        reg = new List(); // If any of the captured strings were non-empty, iterate over them all\n\n    if (has) {\n      for (var _i = 1; _i <= 9; _i++) {\n        var m = regExpCache['$' + _i]; // If it's empty, add an empty capturing group\n\n        if (!m) lm = '()' + lm; // Else find the string in lm and escape & wrap it to capture it\n        else {\n            m = m.replace(esc, '\\\\$&');\n            lm = lm.replace(m, '(' + m + ')');\n          } // Push it to the reg and chop lm to make sure further groups come after\n\n        arrPush.call(reg, lm.slice(0, lm.indexOf('(') + 1));\n        lm = lm.slice(lm.indexOf('(') + 1);\n      }\n    }\n\n    var exprStr = arrJoin.call(reg, '') + lm; // Shorten the regex by replacing each part of the expression with a match\n    // for a string of that exact length.  This is safe for the type of\n    // expressions generated above, because the expression matches the whole\n    // match string, so we know each group and each segment between capturing\n    // groups can be matched by its length alone.\n\n    exprStr = exprStr.replace(/(\\\\\\(|\\\\\\)|[^()])+/g, function (match) {\n      return '[\\\\s\\\\S]{' + match.replace('\\\\', '').length + '}';\n    }); // Create the regular expression that will reconstruct the RegExp properties\n\n    var expr = new RegExp(exprStr, regExpCache.multiline ? 'gm' : 'g'); // Set the lastIndex of the generated expression to ensure that the match\n    // is found in the correct index.\n\n    expr.lastIndex = regExpCache.leftContext.length;\n    expr.exec(regExpCache.input);\n  };\n}\n/**\n * Mimics ES5's abstract ToObject() function\n */\n\n\nfunction toObject(arg) {\n  if (arg === null) throw new TypeError('Cannot convert null or undefined to object');\n  if ((typeof arg === 'undefined' ? 'undefined' : babelHelpers$1['typeof'](arg)) === 'object') return arg;\n  return Object(arg);\n}\n\nfunction toNumber(arg) {\n  if (typeof arg === 'number') return arg;\n  return Number(arg);\n}\n\nfunction toInteger(arg) {\n  var number = toNumber(arg);\n  if (isNaN(number)) return 0;\n  if (number === +0 || number === -0 || number === +Infinity || number === -Infinity) return number;\n  if (number < 0) return Math.floor(Math.abs(number)) * -1;\n  return Math.floor(Math.abs(number));\n}\n\nfunction toLength(arg) {\n  var len = toInteger(arg);\n  if (len <= 0) return 0;\n  if (len === Infinity) return Math.pow(2, 53) - 1;\n  return Math.min(len, Math.pow(2, 53) - 1);\n}\n/**\n * Returns \"internal\" properties for an object\n */\n\n\nfunction getInternalProperties(obj) {\n  if (hop.call(obj, '__getInternalProperties')) return obj.__getInternalProperties(secret);\n  return objCreate(null);\n}\n/**\n* Defines regular expressions for various operations related to the BCP 47 syntax,\n* as defined at http://tools.ietf.org/html/bcp47#section-2.1\n*/\n// extlang       = 3ALPHA              ; selected ISO 639 codes\n//                 *2(\"-\" 3ALPHA)      ; permanently reserved\n\n\nvar extlang = '[a-z]{3}(?:-[a-z]{3}){0,2}'; // language      = 2*3ALPHA            ; shortest ISO 639 code\n//                 [\"-\" extlang]       ; sometimes followed by\n//                                     ; extended language subtags\n//               / 4ALPHA              ; or reserved for future use\n//               / 5*8ALPHA            ; or registered language subtag\n\nvar language = '(?:[a-z]{2,3}(?:-' + extlang + ')?|[a-z]{4}|[a-z]{5,8})'; // script        = 4ALPHA              ; ISO 15924 code\n\nvar script = '[a-z]{4}'; // region        = 2ALPHA              ; ISO 3166-1 code\n//               / 3DIGIT              ; UN M.49 code\n\nvar region = '(?:[a-z]{2}|\\\\d{3})'; // variant       = 5*8alphanum         ; registered variants\n//               / (DIGIT 3alphanum)\n\nvar variant = '(?:[a-z0-9]{5,8}|\\\\d[a-z0-9]{3})'; //                                     ; Single alphanumerics\n//                                     ; \"x\" reserved for private use\n// singleton     = DIGIT               ; 0 - 9\n//               / %x41-57             ; A - W\n//               / %x59-5A             ; Y - Z\n//               / %x61-77             ; a - w\n//               / %x79-7A             ; y - z\n\nvar singleton = '[0-9a-wy-z]'; // extension     = singleton 1*(\"-\" (2*8alphanum))\n\nvar extension = singleton + '(?:-[a-z0-9]{2,8})+'; // privateuse    = \"x\" 1*(\"-\" (1*8alphanum))\n\nvar privateuse = 'x(?:-[a-z0-9]{1,8})+'; // irregular     = \"en-GB-oed\"         ; irregular tags do not match\n//               / \"i-ami\"             ; the 'langtag' production and\n//               / \"i-bnn\"             ; would not otherwise be\n//               / \"i-default\"         ; considered 'well-formed'\n//               / \"i-enochian\"        ; These tags are all valid,\n//               / \"i-hak\"             ; but most are deprecated\n//               / \"i-klingon\"         ; in favor of more modern\n//               / \"i-lux\"             ; subtags or subtag\n//               / \"i-mingo\"           ; combination\n//               / \"i-navajo\"\n//               / \"i-pwn\"\n//               / \"i-tao\"\n//               / \"i-tay\"\n//               / \"i-tsu\"\n//               / \"sgn-BE-FR\"\n//               / \"sgn-BE-NL\"\n//               / \"sgn-CH-DE\"\n\nvar irregular = '(?:en-GB-oed' + '|i-(?:ami|bnn|default|enochian|hak|klingon|lux|mingo|navajo|pwn|tao|tay|tsu)' + '|sgn-(?:BE-FR|BE-NL|CH-DE))'; // regular       = \"art-lojban\"        ; these tags match the 'langtag'\n//               / \"cel-gaulish\"       ; production, but their subtags\n//               / \"no-bok\"            ; are not extended language\n//               / \"no-nyn\"            ; or variant subtags: their meaning\n//               / \"zh-guoyu\"          ; is defined by their registration\n//               / \"zh-hakka\"          ; and all of these are deprecated\n//               / \"zh-min\"            ; in favor of a more modern\n//               / \"zh-min-nan\"        ; subtag or sequence of subtags\n//               / \"zh-xiang\"\n\nvar regular = '(?:art-lojban|cel-gaulish|no-bok|no-nyn' + '|zh-(?:guoyu|hakka|min|min-nan|xiang))'; // grandfathered = irregular           ; non-redundant tags registered\n//               / regular             ; during the RFC 3066 era\n\nvar grandfathered = '(?:' + irregular + '|' + regular + ')'; // langtag       = language\n//                 [\"-\" script]\n//                 [\"-\" region]\n//                 *(\"-\" variant)\n//                 *(\"-\" extension)\n//                 [\"-\" privateuse]\n\nvar langtag = language + '(?:-' + script + ')?(?:-' + region + ')?(?:-' + variant + ')*(?:-' + extension + ')*(?:-' + privateuse + ')?'; // Language-Tag  = langtag             ; normal language tags\n//               / privateuse          ; private use tag\n//               / grandfathered       ; grandfathered tags\n\nvar expBCP47Syntax = RegExp('^(?:' + langtag + '|' + privateuse + '|' + grandfathered + ')$', 'i'); // Match duplicate variants in a language tag\n\nvar expVariantDupes = RegExp('^(?!x).*?-(' + variant + ')-(?:\\\\w{4,8}-(?!x-))*\\\\1\\\\b', 'i'); // Match duplicate singletons in a language tag (except in private use)\n\nvar expSingletonDupes = RegExp('^(?!x).*?-(' + singleton + ')-(?:\\\\w+-(?!x-))*\\\\1\\\\b', 'i'); // Match all extension sequences\n\nvar expExtSequences = RegExp('-' + extension, 'ig'); // Default locale is the first-added locale data for us\n\nvar defaultLocale = void 0;\n\nfunction setDefaultLocale(locale) {\n  defaultLocale = locale;\n} // IANA Subtag Registry redundant tag and subtag maps\n\n\nvar redundantTags = {\n  tags: {\n    \"art-lojban\": \"jbo\",\n    \"i-ami\": \"ami\",\n    \"i-bnn\": \"bnn\",\n    \"i-hak\": \"hak\",\n    \"i-klingon\": \"tlh\",\n    \"i-lux\": \"lb\",\n    \"i-navajo\": \"nv\",\n    \"i-pwn\": \"pwn\",\n    \"i-tao\": \"tao\",\n    \"i-tay\": \"tay\",\n    \"i-tsu\": \"tsu\",\n    \"no-bok\": \"nb\",\n    \"no-nyn\": \"nn\",\n    \"sgn-BE-FR\": \"sfb\",\n    \"sgn-BE-NL\": \"vgt\",\n    \"sgn-CH-DE\": \"sgg\",\n    \"zh-guoyu\": \"cmn\",\n    \"zh-hakka\": \"hak\",\n    \"zh-min-nan\": \"nan\",\n    \"zh-xiang\": \"hsn\",\n    \"sgn-BR\": \"bzs\",\n    \"sgn-CO\": \"csn\",\n    \"sgn-DE\": \"gsg\",\n    \"sgn-DK\": \"dsl\",\n    \"sgn-ES\": \"ssp\",\n    \"sgn-FR\": \"fsl\",\n    \"sgn-GB\": \"bfi\",\n    \"sgn-GR\": \"gss\",\n    \"sgn-IE\": \"isg\",\n    \"sgn-IT\": \"ise\",\n    \"sgn-JP\": \"jsl\",\n    \"sgn-MX\": \"mfs\",\n    \"sgn-NI\": \"ncs\",\n    \"sgn-NL\": \"dse\",\n    \"sgn-NO\": \"nsl\",\n    \"sgn-PT\": \"psr\",\n    \"sgn-SE\": \"swl\",\n    \"sgn-US\": \"ase\",\n    \"sgn-ZA\": \"sfs\",\n    \"zh-cmn\": \"cmn\",\n    \"zh-cmn-Hans\": \"cmn-Hans\",\n    \"zh-cmn-Hant\": \"cmn-Hant\",\n    \"zh-gan\": \"gan\",\n    \"zh-wuu\": \"wuu\",\n    \"zh-yue\": \"yue\"\n  },\n  subtags: {\n    BU: \"MM\",\n    DD: \"DE\",\n    FX: \"FR\",\n    TP: \"TL\",\n    YD: \"YE\",\n    ZR: \"CD\",\n    heploc: \"alalc97\",\n    'in': \"id\",\n    iw: \"he\",\n    ji: \"yi\",\n    jw: \"jv\",\n    mo: \"ro\",\n    ayx: \"nun\",\n    bjd: \"drl\",\n    ccq: \"rki\",\n    cjr: \"mom\",\n    cka: \"cmr\",\n    cmk: \"xch\",\n    drh: \"khk\",\n    drw: \"prs\",\n    gav: \"dev\",\n    hrr: \"jal\",\n    ibi: \"opa\",\n    kgh: \"kml\",\n    lcq: \"ppr\",\n    mst: \"mry\",\n    myt: \"mry\",\n    sca: \"hle\",\n    tie: \"ras\",\n    tkk: \"twm\",\n    tlw: \"weo\",\n    tnf: \"prs\",\n    ybd: \"rki\",\n    yma: \"lrr\"\n  },\n  extLang: {\n    aao: [\"aao\", \"ar\"],\n    abh: [\"abh\", \"ar\"],\n    abv: [\"abv\", \"ar\"],\n    acm: [\"acm\", \"ar\"],\n    acq: [\"acq\", \"ar\"],\n    acw: [\"acw\", \"ar\"],\n    acx: [\"acx\", \"ar\"],\n    acy: [\"acy\", \"ar\"],\n    adf: [\"adf\", \"ar\"],\n    ads: [\"ads\", \"sgn\"],\n    aeb: [\"aeb\", \"ar\"],\n    aec: [\"aec\", \"ar\"],\n    aed: [\"aed\", \"sgn\"],\n    aen: [\"aen\", \"sgn\"],\n    afb: [\"afb\", \"ar\"],\n    afg: [\"afg\", \"sgn\"],\n    ajp: [\"ajp\", \"ar\"],\n    apc: [\"apc\", \"ar\"],\n    apd: [\"apd\", \"ar\"],\n    arb: [\"arb\", \"ar\"],\n    arq: [\"arq\", \"ar\"],\n    ars: [\"ars\", \"ar\"],\n    ary: [\"ary\", \"ar\"],\n    arz: [\"arz\", \"ar\"],\n    ase: [\"ase\", \"sgn\"],\n    asf: [\"asf\", \"sgn\"],\n    asp: [\"asp\", \"sgn\"],\n    asq: [\"asq\", \"sgn\"],\n    asw: [\"asw\", \"sgn\"],\n    auz: [\"auz\", \"ar\"],\n    avl: [\"avl\", \"ar\"],\n    ayh: [\"ayh\", \"ar\"],\n    ayl: [\"ayl\", \"ar\"],\n    ayn: [\"ayn\", \"ar\"],\n    ayp: [\"ayp\", \"ar\"],\n    bbz: [\"bbz\", \"ar\"],\n    bfi: [\"bfi\", \"sgn\"],\n    bfk: [\"bfk\", \"sgn\"],\n    bjn: [\"bjn\", \"ms\"],\n    bog: [\"bog\", \"sgn\"],\n    bqn: [\"bqn\", \"sgn\"],\n    bqy: [\"bqy\", \"sgn\"],\n    btj: [\"btj\", \"ms\"],\n    bve: [\"bve\", \"ms\"],\n    bvl: [\"bvl\", \"sgn\"],\n    bvu: [\"bvu\", \"ms\"],\n    bzs: [\"bzs\", \"sgn\"],\n    cdo: [\"cdo\", \"zh\"],\n    cds: [\"cds\", \"sgn\"],\n    cjy: [\"cjy\", \"zh\"],\n    cmn: [\"cmn\", \"zh\"],\n    coa: [\"coa\", \"ms\"],\n    cpx: [\"cpx\", \"zh\"],\n    csc: [\"csc\", \"sgn\"],\n    csd: [\"csd\", \"sgn\"],\n    cse: [\"cse\", \"sgn\"],\n    csf: [\"csf\", \"sgn\"],\n    csg: [\"csg\", \"sgn\"],\n    csl: [\"csl\", \"sgn\"],\n    csn: [\"csn\", \"sgn\"],\n    csq: [\"csq\", \"sgn\"],\n    csr: [\"csr\", \"sgn\"],\n    czh: [\"czh\", \"zh\"],\n    czo: [\"czo\", \"zh\"],\n    doq: [\"doq\", \"sgn\"],\n    dse: [\"dse\", \"sgn\"],\n    dsl: [\"dsl\", \"sgn\"],\n    dup: [\"dup\", \"ms\"],\n    ecs: [\"ecs\", \"sgn\"],\n    esl: [\"esl\", \"sgn\"],\n    esn: [\"esn\", \"sgn\"],\n    eso: [\"eso\", \"sgn\"],\n    eth: [\"eth\", \"sgn\"],\n    fcs: [\"fcs\", \"sgn\"],\n    fse: [\"fse\", \"sgn\"],\n    fsl: [\"fsl\", \"sgn\"],\n    fss: [\"fss\", \"sgn\"],\n    gan: [\"gan\", \"zh\"],\n    gds: [\"gds\", \"sgn\"],\n    gom: [\"gom\", \"kok\"],\n    gse: [\"gse\", \"sgn\"],\n    gsg: [\"gsg\", \"sgn\"],\n    gsm: [\"gsm\", \"sgn\"],\n    gss: [\"gss\", \"sgn\"],\n    gus: [\"gus\", \"sgn\"],\n    hab: [\"hab\", \"sgn\"],\n    haf: [\"haf\", \"sgn\"],\n    hak: [\"hak\", \"zh\"],\n    hds: [\"hds\", \"sgn\"],\n    hji: [\"hji\", \"ms\"],\n    hks: [\"hks\", \"sgn\"],\n    hos: [\"hos\", \"sgn\"],\n    hps: [\"hps\", \"sgn\"],\n    hsh: [\"hsh\", \"sgn\"],\n    hsl: [\"hsl\", \"sgn\"],\n    hsn: [\"hsn\", \"zh\"],\n    icl: [\"icl\", \"sgn\"],\n    ils: [\"ils\", \"sgn\"],\n    inl: [\"inl\", \"sgn\"],\n    ins: [\"ins\", \"sgn\"],\n    ise: [\"ise\", \"sgn\"],\n    isg: [\"isg\", \"sgn\"],\n    isr: [\"isr\", \"sgn\"],\n    jak: [\"jak\", \"ms\"],\n    jax: [\"jax\", \"ms\"],\n    jcs: [\"jcs\", \"sgn\"],\n    jhs: [\"jhs\", \"sgn\"],\n    jls: [\"jls\", \"sgn\"],\n    jos: [\"jos\", \"sgn\"],\n    jsl: [\"jsl\", \"sgn\"],\n    jus: [\"jus\", \"sgn\"],\n    kgi: [\"kgi\", \"sgn\"],\n    knn: [\"knn\", \"kok\"],\n    kvb: [\"kvb\", \"ms\"],\n    kvk: [\"kvk\", \"sgn\"],\n    kvr: [\"kvr\", \"ms\"],\n    kxd: [\"kxd\", \"ms\"],\n    lbs: [\"lbs\", \"sgn\"],\n    lce: [\"lce\", \"ms\"],\n    lcf: [\"lcf\", \"ms\"],\n    liw: [\"liw\", \"ms\"],\n    lls: [\"lls\", \"sgn\"],\n    lsg: [\"lsg\", \"sgn\"],\n    lsl: [\"lsl\", \"sgn\"],\n    lso: [\"lso\", \"sgn\"],\n    lsp: [\"lsp\", \"sgn\"],\n    lst: [\"lst\", \"sgn\"],\n    lsy: [\"lsy\", \"sgn\"],\n    ltg: [\"ltg\", \"lv\"],\n    lvs: [\"lvs\", \"lv\"],\n    lzh: [\"lzh\", \"zh\"],\n    max: [\"max\", \"ms\"],\n    mdl: [\"mdl\", \"sgn\"],\n    meo: [\"meo\", \"ms\"],\n    mfa: [\"mfa\", \"ms\"],\n    mfb: [\"mfb\", \"ms\"],\n    mfs: [\"mfs\", \"sgn\"],\n    min: [\"min\", \"ms\"],\n    mnp: [\"mnp\", \"zh\"],\n    mqg: [\"mqg\", \"ms\"],\n    mre: [\"mre\", \"sgn\"],\n    msd: [\"msd\", \"sgn\"],\n    msi: [\"msi\", \"ms\"],\n    msr: [\"msr\", \"sgn\"],\n    mui: [\"mui\", \"ms\"],\n    mzc: [\"mzc\", \"sgn\"],\n    mzg: [\"mzg\", \"sgn\"],\n    mzy: [\"mzy\", \"sgn\"],\n    nan: [\"nan\", \"zh\"],\n    nbs: [\"nbs\", \"sgn\"],\n    ncs: [\"ncs\", \"sgn\"],\n    nsi: [\"nsi\", \"sgn\"],\n    nsl: [\"nsl\", \"sgn\"],\n    nsp: [\"nsp\", \"sgn\"],\n    nsr: [\"nsr\", \"sgn\"],\n    nzs: [\"nzs\", \"sgn\"],\n    okl: [\"okl\", \"sgn\"],\n    orn: [\"orn\", \"ms\"],\n    ors: [\"ors\", \"ms\"],\n    pel: [\"pel\", \"ms\"],\n    pga: [\"pga\", \"ar\"],\n    pks: [\"pks\", \"sgn\"],\n    prl: [\"prl\", \"sgn\"],\n    prz: [\"prz\", \"sgn\"],\n    psc: [\"psc\", \"sgn\"],\n    psd: [\"psd\", \"sgn\"],\n    pse: [\"pse\", \"ms\"],\n    psg: [\"psg\", \"sgn\"],\n    psl: [\"psl\", \"sgn\"],\n    pso: [\"pso\", \"sgn\"],\n    psp: [\"psp\", \"sgn\"],\n    psr: [\"psr\", \"sgn\"],\n    pys: [\"pys\", \"sgn\"],\n    rms: [\"rms\", \"sgn\"],\n    rsi: [\"rsi\", \"sgn\"],\n    rsl: [\"rsl\", \"sgn\"],\n    sdl: [\"sdl\", \"sgn\"],\n    sfb: [\"sfb\", \"sgn\"],\n    sfs: [\"sfs\", \"sgn\"],\n    sgg: [\"sgg\", \"sgn\"],\n    sgx: [\"sgx\", \"sgn\"],\n    shu: [\"shu\", \"ar\"],\n    slf: [\"slf\", \"sgn\"],\n    sls: [\"sls\", \"sgn\"],\n    sqk: [\"sqk\", \"sgn\"],\n    sqs: [\"sqs\", \"sgn\"],\n    ssh: [\"ssh\", \"ar\"],\n    ssp: [\"ssp\", \"sgn\"],\n    ssr: [\"ssr\", \"sgn\"],\n    svk: [\"svk\", \"sgn\"],\n    swc: [\"swc\", \"sw\"],\n    swh: [\"swh\", \"sw\"],\n    swl: [\"swl\", \"sgn\"],\n    syy: [\"syy\", \"sgn\"],\n    tmw: [\"tmw\", \"ms\"],\n    tse: [\"tse\", \"sgn\"],\n    tsm: [\"tsm\", \"sgn\"],\n    tsq: [\"tsq\", \"sgn\"],\n    tss: [\"tss\", \"sgn\"],\n    tsy: [\"tsy\", \"sgn\"],\n    tza: [\"tza\", \"sgn\"],\n    ugn: [\"ugn\", \"sgn\"],\n    ugy: [\"ugy\", \"sgn\"],\n    ukl: [\"ukl\", \"sgn\"],\n    uks: [\"uks\", \"sgn\"],\n    urk: [\"urk\", \"ms\"],\n    uzn: [\"uzn\", \"uz\"],\n    uzs: [\"uzs\", \"uz\"],\n    vgt: [\"vgt\", \"sgn\"],\n    vkk: [\"vkk\", \"ms\"],\n    vkt: [\"vkt\", \"ms\"],\n    vsi: [\"vsi\", \"sgn\"],\n    vsl: [\"vsl\", \"sgn\"],\n    vsv: [\"vsv\", \"sgn\"],\n    wuu: [\"wuu\", \"zh\"],\n    xki: [\"xki\", \"sgn\"],\n    xml: [\"xml\", \"sgn\"],\n    xmm: [\"xmm\", \"ms\"],\n    xms: [\"xms\", \"sgn\"],\n    yds: [\"yds\", \"sgn\"],\n    ysl: [\"ysl\", \"sgn\"],\n    yue: [\"yue\", \"zh\"],\n    zib: [\"zib\", \"sgn\"],\n    zlm: [\"zlm\", \"ms\"],\n    zmi: [\"zmi\", \"ms\"],\n    zsl: [\"zsl\", \"sgn\"],\n    zsm: [\"zsm\", \"ms\"]\n  }\n};\n/**\n * Convert only a-z to uppercase as per section 6.1 of the spec\n */\n\nfunction toLatinUpperCase(str) {\n  var i = str.length;\n\n  while (i--) {\n    var ch = str.charAt(i);\n    if (ch >= \"a\" && ch <= \"z\") str = str.slice(0, i) + ch.toUpperCase() + str.slice(i + 1);\n  }\n\n  return str;\n}\n/**\n * The IsStructurallyValidLanguageTag abstract operation verifies that the locale\n * argument (which must be a String value)\n *\n * - represents a well-formed BCP 47 language tag as specified in RFC 5646 section\n *   2.1, or successor,\n * - does not include duplicate variant subtags, and\n * - does not include duplicate singleton subtags.\n *\n * The abstract operation returns true if locale can be generated from the ABNF\n * grammar in section 2.1 of the RFC, starting with Language-Tag, and does not\n * contain duplicate variant or singleton subtags (other than as a private use\n * subtag). It returns false otherwise. Terminal value characters in the grammar are\n * interpreted as the Unicode equivalents of the ASCII octet values given.\n */\n\n\nfunction\n/* 6.2.2 */\nIsStructurallyValidLanguageTag(locale) {\n  // represents a well-formed BCP 47 language tag as specified in RFC 5646\n  if (!expBCP47Syntax.test(locale)) return false; // does not include duplicate variant subtags, and\n\n  if (expVariantDupes.test(locale)) return false; // does not include duplicate singleton subtags.\n\n  if (expSingletonDupes.test(locale)) return false;\n  return true;\n}\n/**\n * The CanonicalizeLanguageTag abstract operation returns the canonical and case-\n * regularized form of the locale argument (which must be a String value that is\n * a structurally valid BCP 47 language tag as verified by the\n * IsStructurallyValidLanguageTag abstract operation). It takes the steps\n * specified in RFC 5646 section 4.5, or successor, to bring the language tag\n * into canonical form, and to regularize the case of the subtags, but does not\n * take the steps to bring a language tag into “extlang form” and to reorder\n * variant subtags.\n\n * The specifications for extensions to BCP 47 language tags, such as RFC 6067,\n * may include canonicalization rules for the extension subtag sequences they\n * define that go beyond the canonicalization rules of RFC 5646 section 4.5.\n * Implementations are allowed, but not required, to apply these additional rules.\n */\n\n\nfunction\n/* 6.2.3 */\nCanonicalizeLanguageTag(locale) {\n  var match = void 0,\n      parts = void 0; // A language tag is in 'canonical form' when the tag is well-formed\n  // according to the rules in Sections 2.1 and 2.2\n  // Section 2.1 says all subtags use lowercase...\n\n  locale = locale.toLowerCase(); // ...with 2 exceptions: 'two-letter and four-letter subtags that neither\n  // appear at the start of the tag nor occur after singletons.  Such two-letter\n  // subtags are all uppercase (as in the tags \"en-CA-x-ca\" or \"sgn-BE-FR\") and\n  // four-letter subtags are titlecase (as in the tag \"az-Latn-x-latn\").\n\n  parts = locale.split('-');\n\n  for (var i = 1, max = parts.length; i < max; i++) {\n    // Two-letter subtags are all uppercase\n    if (parts[i].length === 2) parts[i] = parts[i].toUpperCase(); // Four-letter subtags are titlecase\n    else if (parts[i].length === 4) parts[i] = parts[i].charAt(0).toUpperCase() + parts[i].slice(1); // Is it a singleton?\n      else if (parts[i].length === 1 && parts[i] !== 'x') break;\n  }\n\n  locale = arrJoin.call(parts, '-'); // The steps laid out in RFC 5646 section 4.5 are as follows:\n  // 1.  Extension sequences are ordered into case-insensitive ASCII order\n  //     by singleton subtag.\n\n  if ((match = locale.match(expExtSequences)) && match.length > 1) {\n    // The built-in sort() sorts by ASCII order, so use that\n    match.sort(); // Replace all extensions with the joined, sorted array\n\n    locale = locale.replace(RegExp('(?:' + expExtSequences.source + ')+', 'i'), arrJoin.call(match, ''));\n  } // 2.  Redundant or grandfathered tags are replaced by their 'Preferred-\n  //     Value', if there is one.\n\n\n  if (hop.call(redundantTags.tags, locale)) locale = redundantTags.tags[locale]; // 3.  Subtags are replaced by their 'Preferred-Value', if there is one.\n  //     For extlangs, the original primary language subtag is also\n  //     replaced if there is a primary language subtag in the 'Preferred-\n  //     Value'.\n\n  parts = locale.split('-');\n\n  for (var _i = 1, _max = parts.length; _i < _max; _i++) {\n    if (hop.call(redundantTags.subtags, parts[_i])) parts[_i] = redundantTags.subtags[parts[_i]];else if (hop.call(redundantTags.extLang, parts[_i])) {\n      parts[_i] = redundantTags.extLang[parts[_i]][0]; // For extlang tags, the prefix needs to be removed if it is redundant\n\n      if (_i === 1 && redundantTags.extLang[parts[1]][1] === parts[0]) {\n        parts = arrSlice.call(parts, _i++);\n        _max -= 1;\n      }\n    }\n  }\n\n  return arrJoin.call(parts, '-');\n}\n/**\n * The DefaultLocale abstract operation returns a String value representing the\n * structurally valid (6.2.2) and canonicalized (6.2.3) BCP 47 language tag for the\n * host environment’s current locale.\n */\n\n\nfunction\n/* 6.2.4 */\nDefaultLocale() {\n  return defaultLocale;\n} // Sect 6.3 Currency Codes\n// =======================\n\n\nvar expCurrencyCode = /^[A-Z]{3}$/;\n/**\n * The IsWellFormedCurrencyCode abstract operation verifies that the currency argument\n * (after conversion to a String value) represents a well-formed 3-letter ISO currency\n * code. The following steps are taken:\n */\n\nfunction\n/* 6.3.1 */\nIsWellFormedCurrencyCode(currency) {\n  // 1. Let `c` be ToString(currency)\n  var c = String(currency); // 2. Let `normalized` be the result of mapping c to upper case as described\n  //    in 6.1.\n\n  var normalized = toLatinUpperCase(c); // 3. If the string length of normalized is not 3, return false.\n  // 4. If normalized contains any character that is not in the range \"A\" to \"Z\"\n  //    (U+0041 to U+005A), return false.\n\n  if (expCurrencyCode.test(normalized) === false) return false; // 5. Return true\n\n  return true;\n}\n\nvar expUnicodeExSeq = /-u(?:-[0-9a-z]{2,8})+/gi; // See `extension` below\n\nfunction\n/* 9.2.1 */\nCanonicalizeLocaleList(locales) {\n  // The abstract operation CanonicalizeLocaleList takes the following steps:\n  // 1. If locales is undefined, then a. Return a new empty List\n  if (locales === undefined) return new List(); // 2. Let seen be a new empty List.\n\n  var seen = new List(); // 3. If locales is a String value, then\n  //    a. Let locales be a new array created as if by the expression new\n  //    Array(locales) where Array is the standard built-in constructor with\n  //    that name and locales is the value of locales.\n\n  locales = typeof locales === 'string' ? [locales] : locales; // 4. Let O be ToObject(locales).\n\n  var O = toObject(locales); // 5. Let lenValue be the result of calling the [[Get]] internal method of\n  //    O with the argument \"length\".\n  // 6. Let len be ToUint32(lenValue).\n\n  var len = toLength(O.length); // 7. Let k be 0.\n\n  var k = 0; // 8. Repeat, while k < len\n\n  while (k < len) {\n    // a. Let Pk be ToString(k).\n    var Pk = String(k); // b. Let kPresent be the result of calling the [[HasProperty]] internal\n    //    method of O with argument Pk.\n\n    var kPresent = Pk in O; // c. If kPresent is true, then\n\n    if (kPresent) {\n      // i. Let kValue be the result of calling the [[Get]] internal\n      //     method of O with argument Pk.\n      var kValue = O[Pk]; // ii. If the type of kValue is not String or Object, then throw a\n      //     TypeError exception.\n\n      if (kValue === null || typeof kValue !== 'string' && (typeof kValue === \"undefined\" ? \"undefined\" : babelHelpers$1[\"typeof\"](kValue)) !== 'object') throw new TypeError('String or Object type expected'); // iii. Let tag be ToString(kValue).\n\n      var tag = String(kValue); // iv. If the result of calling the abstract operation\n      //     IsStructurallyValidLanguageTag (defined in 6.2.2), passing tag as\n      //     the argument, is false, then throw a RangeError exception.\n\n      if (!IsStructurallyValidLanguageTag(tag)) throw new RangeError(\"'\" + tag + \"' is not a structurally valid language tag\"); // v. Let tag be the result of calling the abstract operation\n      //    CanonicalizeLanguageTag (defined in 6.2.3), passing tag as the\n      //    argument.\n\n      tag = CanonicalizeLanguageTag(tag); // vi. If tag is not an element of seen, then append tag as the last\n      //     element of seen.\n\n      if (arrIndexOf.call(seen, tag) === -1) arrPush.call(seen, tag);\n    } // d. Increase k by 1.\n\n\n    k++;\n  } // 9. Return seen.\n\n\n  return seen;\n}\n/**\n * The BestAvailableLocale abstract operation compares the provided argument\n * locale, which must be a String value with a structurally valid and\n * canonicalized BCP 47 language tag, against the locales in availableLocales and\n * returns either the longest non-empty prefix of locale that is an element of\n * availableLocales, or undefined if there is no such element. It uses the\n * fallback mechanism of RFC 4647, section 3.4. The following steps are taken:\n */\n\n\nfunction\n/* 9.2.2 */\nBestAvailableLocale(availableLocales, locale) {\n  // 1. Let candidate be locale\n  var candidate = locale; // 2. Repeat\n\n  while (candidate) {\n    // a. If availableLocales contains an element equal to candidate, then return\n    // candidate.\n    if (arrIndexOf.call(availableLocales, candidate) > -1) return candidate; // b. Let pos be the character index of the last occurrence of \"-\"\n    // (U+002D) within candidate. If that character does not occur, return\n    // undefined.\n\n    var pos = candidate.lastIndexOf('-');\n    if (pos < 0) return; // c. If pos ≥ 2 and the character \"-\" occurs at index pos-2 of candidate,\n    //    then decrease pos by 2.\n\n    if (pos >= 2 && candidate.charAt(pos - 2) === '-') pos -= 2; // d. Let candidate be the substring of candidate from position 0, inclusive,\n    //    to position pos, exclusive.\n\n    candidate = candidate.substring(0, pos);\n  }\n}\n/**\n * The LookupMatcher abstract operation compares requestedLocales, which must be\n * a List as returned by CanonicalizeLocaleList, against the locales in\n * availableLocales and determines the best available language to meet the\n * request. The following steps are taken:\n */\n\n\nfunction\n/* 9.2.3 */\nLookupMatcher(availableLocales, requestedLocales) {\n  // 1. Let i be 0.\n  var i = 0; // 2. Let len be the number of elements in requestedLocales.\n\n  var len = requestedLocales.length; // 3. Let availableLocale be undefined.\n\n  var availableLocale = void 0;\n  var locale = void 0,\n      noExtensionsLocale = void 0; // 4. Repeat while i < len and availableLocale is undefined:\n\n  while (i < len && !availableLocale) {\n    // a. Let locale be the element of requestedLocales at 0-origined list\n    //    position i.\n    locale = requestedLocales[i]; // b. Let noExtensionsLocale be the String value that is locale with all\n    //    Unicode locale extension sequences removed.\n\n    noExtensionsLocale = String(locale).replace(expUnicodeExSeq, ''); // c. Let availableLocale be the result of calling the\n    //    BestAvailableLocale abstract operation (defined in 9.2.2) with\n    //    arguments availableLocales and noExtensionsLocale.\n\n    availableLocale = BestAvailableLocale(availableLocales, noExtensionsLocale); // d. Increase i by 1.\n\n    i++;\n  } // 5. Let result be a new Record.\n\n\n  var result = new Record(); // 6. If availableLocale is not undefined, then\n\n  if (availableLocale !== undefined) {\n    // a. Set result.[[locale]] to availableLocale.\n    result['[[locale]]'] = availableLocale; // b. If locale and noExtensionsLocale are not the same String value, then\n\n    if (String(locale) !== String(noExtensionsLocale)) {\n      // i. Let extension be the String value consisting of the first\n      //    substring of locale that is a Unicode locale extension sequence.\n      var extension = locale.match(expUnicodeExSeq)[0]; // ii. Let extensionIndex be the character position of the initial\n      //     \"-\" of the first Unicode locale extension sequence within locale.\n\n      var extensionIndex = locale.indexOf('-u-'); // iii. Set result.[[extension]] to extension.\n\n      result['[[extension]]'] = extension; // iv. Set result.[[extensionIndex]] to extensionIndex.\n\n      result['[[extensionIndex]]'] = extensionIndex;\n    }\n  } // 7. Else\n  else // a. Set result.[[locale]] to the value returned by the DefaultLocale abstract\n    //    operation (defined in 6.2.4).\n    result['[[locale]]'] = DefaultLocale(); // 8. Return result\n\n\n  return result;\n}\n/**\n * The BestFitMatcher abstract operation compares requestedLocales, which must be\n * a List as returned by CanonicalizeLocaleList, against the locales in\n * availableLocales and determines the best available language to meet the\n * request. The algorithm is implementation dependent, but should produce results\n * that a typical user of the requested locales would perceive as at least as\n * good as those produced by the LookupMatcher abstract operation. Options\n * specified through Unicode locale extension sequences must be ignored by the\n * algorithm. Information about such subsequences is returned separately.\n * The abstract operation returns a record with a [[locale]] field, whose value\n * is the language tag of the selected locale, which must be an element of\n * availableLocales. If the language tag of the request locale that led to the\n * selected locale contained a Unicode locale extension sequence, then the\n * returned record also contains an [[extension]] field whose value is the first\n * Unicode locale extension sequence, and an [[extensionIndex]] field whose value\n * is the index of the first Unicode locale extension sequence within the request\n * locale language tag.\n */\n\n\nfunction\n/* 9.2.4 */\nBestFitMatcher(availableLocales, requestedLocales) {\n  return LookupMatcher(availableLocales, requestedLocales);\n}\n/**\n * The ResolveLocale abstract operation compares a BCP 47 language priority list\n * requestedLocales against the locales in availableLocales and determines the\n * best available language to meet the request. availableLocales and\n * requestedLocales must be provided as List values, options as a Record.\n */\n\n\nfunction\n/* 9.2.5 */\nResolveLocale(availableLocales, requestedLocales, options, relevantExtensionKeys, localeData) {\n  if (availableLocales.length === 0) {\n    throw new ReferenceError('No locale data has been provided for this object yet.');\n  } // The following steps are taken:\n  // 1. Let matcher be the value of options.[[localeMatcher]].\n\n\n  var matcher = options['[[localeMatcher]]'];\n  var r = void 0; // 2. If matcher is \"lookup\", then\n\n  if (matcher === 'lookup') // a. Let r be the result of calling the LookupMatcher abstract operation\n    //    (defined in 9.2.3) with arguments availableLocales and\n    //    requestedLocales.\n    r = LookupMatcher(availableLocales, requestedLocales); // 3. Else\n  else // a. Let r be the result of calling the BestFitMatcher abstract\n    //    operation (defined in 9.2.4) with arguments availableLocales and\n    //    requestedLocales.\n    r = BestFitMatcher(availableLocales, requestedLocales); // 4. Let foundLocale be the value of r.[[locale]].\n\n  var foundLocale = r['[[locale]]'];\n  var extensionSubtags = void 0,\n      extensionSubtagsLength = void 0; // 5. If r has an [[extension]] field, then\n\n  if (hop.call(r, '[[extension]]')) {\n    // a. Let extension be the value of r.[[extension]].\n    var extension = r['[[extension]]']; // b. Let split be the standard built-in function object defined in ES5,\n    //    15.5.4.14.\n\n    var split = String.prototype.split; // c. Let extensionSubtags be the result of calling the [[Call]] internal\n    //    method of split with extension as the this value and an argument\n    //    list containing the single item \"-\".\n\n    extensionSubtags = split.call(extension, '-'); // d. Let extensionSubtagsLength be the result of calling the [[Get]]\n    //    internal method of extensionSubtags with argument \"length\".\n\n    extensionSubtagsLength = extensionSubtags.length;\n  } // 6. Let result be a new Record.\n\n\n  var result = new Record(); // 7. Set result.[[dataLocale]] to foundLocale.\n\n  result['[[dataLocale]]'] = foundLocale; // 8. Let supportedExtension be \"-u\".\n\n  var supportedExtension = '-u'; // 9. Let i be 0.\n\n  var i = 0; // 10. Let len be the result of calling the [[Get]] internal method of\n  //     relevantExtensionKeys with argument \"length\".\n\n  var len = relevantExtensionKeys.length; // 11 Repeat while i < len:\n\n  while (i < len) {\n    // a. Let key be the result of calling the [[Get]] internal method of\n    //    relevantExtensionKeys with argument ToString(i).\n    var key = relevantExtensionKeys[i]; // b. Let foundLocaleData be the result of calling the [[Get]] internal\n    //    method of localeData with the argument foundLocale.\n\n    var foundLocaleData = localeData[foundLocale]; // c. Let keyLocaleData be the result of calling the [[Get]] internal\n    //    method of foundLocaleData with the argument key.\n\n    var keyLocaleData = foundLocaleData[key]; // d. Let value be the result of calling the [[Get]] internal method of\n    //    keyLocaleData with argument \"0\".\n\n    var value = keyLocaleData['0']; // e. Let supportedExtensionAddition be \"\".\n\n    var supportedExtensionAddition = ''; // f. Let indexOf be the standard built-in function object defined in\n    //    ES5, 15.4.4.14.\n\n    var indexOf = arrIndexOf; // g. If extensionSubtags is not undefined, then\n\n    if (extensionSubtags !== undefined) {\n      // i. Let keyPos be the result of calling the [[Call]] internal\n      //    method of indexOf with extensionSubtags as the this value and\n      // an argument list containing the single item key.\n      var keyPos = indexOf.call(extensionSubtags, key); // ii. If keyPos ≠ -1, then\n\n      if (keyPos !== -1) {\n        // 1. If keyPos + 1 < extensionSubtagsLength and the length of the\n        //    result of calling the [[Get]] internal method of\n        //    extensionSubtags with argument ToString(keyPos +1) is greater\n        //    than 2, then\n        if (keyPos + 1 < extensionSubtagsLength && extensionSubtags[keyPos + 1].length > 2) {\n          // a. Let requestedValue be the result of calling the [[Get]]\n          //    internal method of extensionSubtags with argument\n          //    ToString(keyPos + 1).\n          var requestedValue = extensionSubtags[keyPos + 1]; // b. Let valuePos be the result of calling the [[Call]]\n          //    internal method of indexOf with keyLocaleData as the\n          //    this value and an argument list containing the single\n          //    item requestedValue.\n\n          var valuePos = indexOf.call(keyLocaleData, requestedValue); // c. If valuePos ≠ -1, then\n\n          if (valuePos !== -1) {\n            // i. Let value be requestedValue.\n            value = requestedValue, // ii. Let supportedExtensionAddition be the\n            //     concatenation of \"-\", key, \"-\", and value.\n            supportedExtensionAddition = '-' + key + '-' + value;\n          }\n        } // 2. Else\n        else {\n            // a. Let valuePos be the result of calling the [[Call]]\n            // internal method of indexOf with keyLocaleData as the this\n            // value and an argument list containing the single item\n            // \"true\".\n            var _valuePos = indexOf(keyLocaleData, 'true'); // b. If valuePos ≠ -1, then\n\n\n            if (_valuePos !== -1) // i. Let value be \"true\".\n              value = 'true';\n          }\n      }\n    } // h. If options has a field [[<key>]], then\n\n\n    if (hop.call(options, '[[' + key + ']]')) {\n      // i. Let optionsValue be the value of options.[[<key>]].\n      var optionsValue = options['[[' + key + ']]']; // ii. If the result of calling the [[Call]] internal method of indexOf\n      //     with keyLocaleData as the this value and an argument list\n      //     containing the single item optionsValue is not -1, then\n\n      if (indexOf.call(keyLocaleData, optionsValue) !== -1) {\n        // 1. If optionsValue is not equal to value, then\n        if (optionsValue !== value) {\n          // a. Let value be optionsValue.\n          value = optionsValue; // b. Let supportedExtensionAddition be \"\".\n\n          supportedExtensionAddition = '';\n        }\n      }\n    } // i. Set result.[[<key>]] to value.\n\n\n    result['[[' + key + ']]'] = value; // j. Append supportedExtensionAddition to supportedExtension.\n\n    supportedExtension += supportedExtensionAddition; // k. Increase i by 1.\n\n    i++;\n  } // 12. If the length of supportedExtension is greater than 2, then\n\n\n  if (supportedExtension.length > 2) {\n    // a.\n    var privateIndex = foundLocale.indexOf(\"-x-\"); // b.\n\n    if (privateIndex === -1) {\n      // i.\n      foundLocale = foundLocale + supportedExtension;\n    } // c.\n    else {\n        // i.\n        var preExtension = foundLocale.substring(0, privateIndex); // ii.\n\n        var postExtension = foundLocale.substring(privateIndex); // iii.\n\n        foundLocale = preExtension + supportedExtension + postExtension;\n      } // d. asserting - skipping\n    // e.\n\n\n    foundLocale = CanonicalizeLanguageTag(foundLocale);\n  } // 13. Set result.[[locale]] to foundLocale.\n\n\n  result['[[locale]]'] = foundLocale; // 14. Return result.\n\n  return result;\n}\n/**\n * The LookupSupportedLocales abstract operation returns the subset of the\n * provided BCP 47 language priority list requestedLocales for which\n * availableLocales has a matching locale when using the BCP 47 Lookup algorithm.\n * Locales appear in the same order in the returned list as in requestedLocales.\n * The following steps are taken:\n */\n\n\nfunction\n/* 9.2.6 */\nLookupSupportedLocales(availableLocales, requestedLocales) {\n  // 1. Let len be the number of elements in requestedLocales.\n  var len = requestedLocales.length; // 2. Let subset be a new empty List.\n\n  var subset = new List(); // 3. Let k be 0.\n\n  var k = 0; // 4. Repeat while k < len\n\n  while (k < len) {\n    // a. Let locale be the element of requestedLocales at 0-origined list\n    //    position k.\n    var locale = requestedLocales[k]; // b. Let noExtensionsLocale be the String value that is locale with all\n    //    Unicode locale extension sequences removed.\n\n    var noExtensionsLocale = String(locale).replace(expUnicodeExSeq, ''); // c. Let availableLocale be the result of calling the\n    //    BestAvailableLocale abstract operation (defined in 9.2.2) with\n    //    arguments availableLocales and noExtensionsLocale.\n\n    var availableLocale = BestAvailableLocale(availableLocales, noExtensionsLocale); // d. If availableLocale is not undefined, then append locale to the end of\n    //    subset.\n\n    if (availableLocale !== undefined) arrPush.call(subset, locale); // e. Increment k by 1.\n\n    k++;\n  } // 5. Let subsetArray be a new Array object whose elements are the same\n  //    values in the same order as the elements of subset.\n\n\n  var subsetArray = arrSlice.call(subset); // 6. Return subsetArray.\n\n  return subsetArray;\n}\n/**\n * The BestFitSupportedLocales abstract operation returns the subset of the\n * provided BCP 47 language priority list requestedLocales for which\n * availableLocales has a matching locale when using the Best Fit Matcher\n * algorithm. Locales appear in the same order in the returned list as in\n * requestedLocales. The steps taken are implementation dependent.\n */\n\n\nfunction\n/*9.2.7 */\nBestFitSupportedLocales(availableLocales, requestedLocales) {\n  // ###TODO: implement this function as described by the specification###\n  return LookupSupportedLocales(availableLocales, requestedLocales);\n}\n/**\n * The SupportedLocales abstract operation returns the subset of the provided BCP\n * 47 language priority list requestedLocales for which availableLocales has a\n * matching locale. Two algorithms are available to match the locales: the Lookup\n * algorithm described in RFC 4647 section 3.4, and an implementation dependent\n * best-fit algorithm. Locales appear in the same order in the returned list as\n * in requestedLocales. The following steps are taken:\n */\n\n\nfunction\n/*9.2.8 */\nSupportedLocales(availableLocales, requestedLocales, options) {\n  var matcher = void 0,\n      subset = void 0; // 1. If options is not undefined, then\n\n  if (options !== undefined) {\n    // a. Let options be ToObject(options).\n    options = new Record(toObject(options)); // b. Let matcher be the result of calling the [[Get]] internal method of\n    //    options with argument \"localeMatcher\".\n\n    matcher = options.localeMatcher; // c. If matcher is not undefined, then\n\n    if (matcher !== undefined) {\n      // i. Let matcher be ToString(matcher).\n      matcher = String(matcher); // ii. If matcher is not \"lookup\" or \"best fit\", then throw a RangeError\n      //     exception.\n\n      if (matcher !== 'lookup' && matcher !== 'best fit') throw new RangeError('matcher should be \"lookup\" or \"best fit\"');\n    }\n  } // 2. If matcher is undefined or \"best fit\", then\n\n\n  if (matcher === undefined || matcher === 'best fit') // a. Let subset be the result of calling the BestFitSupportedLocales\n    //    abstract operation (defined in 9.2.7) with arguments\n    //    availableLocales and requestedLocales.\n    subset = BestFitSupportedLocales(availableLocales, requestedLocales); // 3. Else\n  else // a. Let subset be the result of calling the LookupSupportedLocales\n    //    abstract operation (defined in 9.2.6) with arguments\n    //    availableLocales and requestedLocales.\n    subset = LookupSupportedLocales(availableLocales, requestedLocales); // 4. For each named own property name P of subset,\n\n  for (var P in subset) {\n    if (!hop.call(subset, P)) continue; // a. Let desc be the result of calling the [[GetOwnProperty]] internal\n    //    method of subset with P.\n    // b. Set desc.[[Writable]] to false.\n    // c. Set desc.[[Configurable]] to false.\n    // d. Call the [[DefineOwnProperty]] internal method of subset with P, desc,\n    //    and true as arguments.\n\n    defineProperty(subset, P, {\n      writable: false,\n      configurable: false,\n      value: subset[P]\n    });\n  } // \"Freeze\" the array so no new elements can be added\n\n\n  defineProperty(subset, 'length', {\n    writable: false\n  }); // 5. Return subset\n\n  return subset;\n}\n/**\n * The GetOption abstract operation extracts the value of the property named\n * property from the provided options object, converts it to the required type,\n * checks whether it is one of a List of allowed values, and fills in a fallback\n * value if necessary.\n */\n\n\nfunction\n/*9.2.9 */\nGetOption(options, property, type, values, fallback) {\n  // 1. Let value be the result of calling the [[Get]] internal method of\n  //    options with argument property.\n  var value = options[property]; // 2. If value is not undefined, then\n\n  if (value !== undefined) {\n    // a. Assert: type is \"boolean\" or \"string\".\n    // b. If type is \"boolean\", then let value be ToBoolean(value).\n    // c. If type is \"string\", then let value be ToString(value).\n    value = type === 'boolean' ? Boolean(value) : type === 'string' ? String(value) : value; // d. If values is not undefined, then\n\n    if (values !== undefined) {\n      // i. If values does not contain an element equal to value, then throw a\n      //    RangeError exception.\n      if (arrIndexOf.call(values, value) === -1) throw new RangeError(\"'\" + value + \"' is not an allowed value for `\" + property + '`');\n    } // e. Return value.\n\n\n    return value;\n  } // Else return fallback.\n\n\n  return fallback;\n}\n/**\n * The GetNumberOption abstract operation extracts a property value from the\n * provided options object, converts it to a Number value, checks whether it is\n * in the allowed range, and fills in a fallback value if necessary.\n */\n\n\nfunction\n/* 9.2.10 */\nGetNumberOption(options, property, minimum, maximum, fallback) {\n  // 1. Let value be the result of calling the [[Get]] internal method of\n  //    options with argument property.\n  var value = options[property]; // 2. If value is not undefined, then\n\n  if (value !== undefined) {\n    // a. Let value be ToNumber(value).\n    value = Number(value); // b. If value is NaN or less than minimum or greater than maximum, throw a\n    //    RangeError exception.\n\n    if (isNaN(value) || value < minimum || value > maximum) throw new RangeError('Value is not a number or outside accepted range'); // c. Return floor(value).\n\n    return Math.floor(value);\n  } // 3. Else return fallback.\n\n\n  return fallback;\n} // 8 The Intl Object\n\n\nvar Intl = {}; // 8.2 Function Properties of the Intl Object\n// 8.2.1\n// @spec[tc39/ecma402/master/spec/intl.html]\n// @clause[sec-intl.getcanonicallocales]\n\nfunction getCanonicalLocales(locales) {\n  // 1. Let ll be ? CanonicalizeLocaleList(locales).\n  var ll = CanonicalizeLocaleList(locales); // 2. Return CreateArrayFromList(ll).\n\n  {\n    var result = [];\n    var len = ll.length;\n    var k = 0;\n\n    while (k < len) {\n      result[k] = ll[k];\n      k++;\n    }\n\n    return result;\n  }\n}\n\nObject.defineProperty(Intl, 'getCanonicalLocales', {\n  enumerable: false,\n  configurable: true,\n  writable: true,\n  value: getCanonicalLocales\n}); // Currency minor units output from get-4217 grunt task, formatted\n\nvar currencyMinorUnits = {\n  BHD: 3,\n  BYR: 0,\n  XOF: 0,\n  BIF: 0,\n  XAF: 0,\n  CLF: 4,\n  CLP: 0,\n  KMF: 0,\n  DJF: 0,\n  XPF: 0,\n  GNF: 0,\n  ISK: 0,\n  IQD: 3,\n  JPY: 0,\n  JOD: 3,\n  KRW: 0,\n  KWD: 3,\n  LYD: 3,\n  OMR: 3,\n  PYG: 0,\n  RWF: 0,\n  TND: 3,\n  UGX: 0,\n  UYI: 0,\n  VUV: 0,\n  VND: 0\n}; // Define the NumberFormat constructor internally so it cannot be tainted\n\nfunction NumberFormatConstructor() {\n  var locales = arguments[0];\n  var options = arguments[1];\n\n  if (!this || this === Intl) {\n    return new Intl.NumberFormat(locales, options);\n  }\n\n  return InitializeNumberFormat(toObject(this), locales, options);\n}\n\ndefineProperty(Intl, 'NumberFormat', {\n  configurable: true,\n  writable: true,\n  value: NumberFormatConstructor\n}); // Must explicitly set prototypes as unwritable\n\ndefineProperty(Intl.NumberFormat, 'prototype', {\n  writable: false\n});\n/**\n * The abstract operation InitializeNumberFormat accepts the arguments\n * numberFormat (which must be an object), locales, and options. It initializes\n * numberFormat as a NumberFormat object.\n */\n\nfunction\n/*11.1.1.1 */\nInitializeNumberFormat(numberFormat, locales, options) {\n  // This will be a internal properties object if we're not already initialized\n  var internal = getInternalProperties(numberFormat); // Create an object whose props can be used to restore the values of RegExp props\n\n  var regexpRestore = createRegExpRestore(); // 1. If numberFormat has an [[initializedIntlObject]] internal property with\n  // value true, throw a TypeError exception.\n\n  if (internal['[[initializedIntlObject]]'] === true) throw new TypeError('`this` object has already been initialized as an Intl object'); // Need this to access the `internal` object\n\n  defineProperty(numberFormat, '__getInternalProperties', {\n    value: function value() {\n      // NOTE: Non-standard, for internal use only\n      if (arguments[0] === secret) return internal;\n    }\n  }); // 2. Set the [[initializedIntlObject]] internal property of numberFormat to true.\n\n  internal['[[initializedIntlObject]]'] = true; // 3. Let requestedLocales be the result of calling the CanonicalizeLocaleList\n  //    abstract operation (defined in 9.2.1) with argument locales.\n\n  var requestedLocales = CanonicalizeLocaleList(locales); // 4. If options is undefined, then\n\n  if (options === undefined) // a. Let options be the result of creating a new object as if by the\n    // expression new Object() where Object is the standard built-in constructor\n    // with that name.\n    options = {}; // 5. Else\n  else // a. Let options be ToObject(options).\n    options = toObject(options); // 6. Let opt be a new Record.\n\n  var opt = new Record(),\n      // 7. Let matcher be the result of calling the GetOption abstract operation\n  //    (defined in 9.2.9) with the arguments options, \"localeMatcher\", \"string\",\n  //    a List containing the two String values \"lookup\" and \"best fit\", and\n  //    \"best fit\".\n  matcher = GetOption(options, 'localeMatcher', 'string', new List('lookup', 'best fit'), 'best fit'); // 8. Set opt.[[localeMatcher]] to matcher.\n\n  opt['[[localeMatcher]]'] = matcher; // 9. Let NumberFormat be the standard built-in object that is the initial value\n  //    of Intl.NumberFormat.\n  // 10. Let localeData be the value of the [[localeData]] internal property of\n  //     NumberFormat.\n\n  var localeData = internals.NumberFormat['[[localeData]]']; // 11. Let r be the result of calling the ResolveLocale abstract operation\n  //     (defined in 9.2.5) with the [[availableLocales]] internal property of\n  //     NumberFormat, requestedLocales, opt, the [[relevantExtensionKeys]]\n  //     internal property of NumberFormat, and localeData.\n\n  var r = ResolveLocale(internals.NumberFormat['[[availableLocales]]'], requestedLocales, opt, internals.NumberFormat['[[relevantExtensionKeys]]'], localeData); // 12. Set the [[locale]] internal property of numberFormat to the value of\n  //     r.[[locale]].\n\n  internal['[[locale]]'] = r['[[locale]]']; // 13. Set the [[numberingSystem]] internal property of numberFormat to the value\n  //     of r.[[nu]].\n\n  internal['[[numberingSystem]]'] = r['[[nu]]']; // The specification doesn't tell us to do this, but it's helpful later on\n\n  internal['[[dataLocale]]'] = r['[[dataLocale]]']; // 14. Let dataLocale be the value of r.[[dataLocale]].\n\n  var dataLocale = r['[[dataLocale]]']; // 15. Let s be the result of calling the GetOption abstract operation with the\n  //     arguments options, \"style\", \"string\", a List containing the three String\n  //     values \"decimal\", \"percent\", and \"currency\", and \"decimal\".\n\n  var s = GetOption(options, 'style', 'string', new List('decimal', 'percent', 'currency'), 'decimal'); // 16. Set the [[style]] internal property of numberFormat to s.\n\n  internal['[[style]]'] = s; // 17. Let c be the result of calling the GetOption abstract operation with the\n  //     arguments options, \"currency\", \"string\", undefined, and undefined.\n\n  var c = GetOption(options, 'currency', 'string'); // 18. If c is not undefined and the result of calling the\n  //     IsWellFormedCurrencyCode abstract operation (defined in 6.3.1) with\n  //     argument c is false, then throw a RangeError exception.\n\n  if (c !== undefined && !IsWellFormedCurrencyCode(c)) throw new RangeError(\"'\" + c + \"' is not a valid currency code\"); // 19. If s is \"currency\" and c is undefined, throw a TypeError exception.\n\n  if (s === 'currency' && c === undefined) throw new TypeError('Currency code is required when style is currency');\n  var cDigits = void 0; // 20. If s is \"currency\", then\n\n  if (s === 'currency') {\n    // a. Let c be the result of converting c to upper case as specified in 6.1.\n    c = c.toUpperCase(); // b. Set the [[currency]] internal property of numberFormat to c.\n\n    internal['[[currency]]'] = c; // c. Let cDigits be the result of calling the CurrencyDigits abstract\n    //    operation (defined below) with argument c.\n\n    cDigits = CurrencyDigits(c);\n  } // 21. Let cd be the result of calling the GetOption abstract operation with the\n  //     arguments options, \"currencyDisplay\", \"string\", a List containing the\n  //     three String values \"code\", \"symbol\", and \"name\", and \"symbol\".\n\n\n  var cd = GetOption(options, 'currencyDisplay', 'string', new List('code', 'symbol', 'name'), 'symbol'); // 22. If s is \"currency\", then set the [[currencyDisplay]] internal property of\n  //     numberFormat to cd.\n\n  if (s === 'currency') internal['[[currencyDisplay]]'] = cd; // 23. Let mnid be the result of calling the GetNumberOption abstract operation\n  //     (defined in 9.2.10) with arguments options, \"minimumIntegerDigits\", 1, 21,\n  //     and 1.\n\n  var mnid = GetNumberOption(options, 'minimumIntegerDigits', 1, 21, 1); // 24. Set the [[minimumIntegerDigits]] internal property of numberFormat to mnid.\n\n  internal['[[minimumIntegerDigits]]'] = mnid; // 25. If s is \"currency\", then let mnfdDefault be cDigits; else let mnfdDefault\n  //     be 0.\n\n  var mnfdDefault = s === 'currency' ? cDigits : 0; // 26. Let mnfd be the result of calling the GetNumberOption abstract operation\n  //     with arguments options, \"minimumFractionDigits\", 0, 20, and mnfdDefault.\n\n  var mnfd = GetNumberOption(options, 'minimumFractionDigits', 0, 20, mnfdDefault); // 27. Set the [[minimumFractionDigits]] internal property of numberFormat to mnfd.\n\n  internal['[[minimumFractionDigits]]'] = mnfd; // 28. If s is \"currency\", then let mxfdDefault be max(mnfd, cDigits); else if s\n  //     is \"percent\", then let mxfdDefault be max(mnfd, 0); else let mxfdDefault\n  //     be max(mnfd, 3).\n\n  var mxfdDefault = s === 'currency' ? Math.max(mnfd, cDigits) : s === 'percent' ? Math.max(mnfd, 0) : Math.max(mnfd, 3); // 29. Let mxfd be the result of calling the GetNumberOption abstract operation\n  //     with arguments options, \"maximumFractionDigits\", mnfd, 20, and mxfdDefault.\n\n  var mxfd = GetNumberOption(options, 'maximumFractionDigits', mnfd, 20, mxfdDefault); // 30. Set the [[maximumFractionDigits]] internal property of numberFormat to mxfd.\n\n  internal['[[maximumFractionDigits]]'] = mxfd; // 31. Let mnsd be the result of calling the [[Get]] internal method of options\n  //     with argument \"minimumSignificantDigits\".\n\n  var mnsd = options.minimumSignificantDigits; // 32. Let mxsd be the result of calling the [[Get]] internal method of options\n  //     with argument \"maximumSignificantDigits\".\n\n  var mxsd = options.maximumSignificantDigits; // 33. If mnsd is not undefined or mxsd is not undefined, then:\n\n  if (mnsd !== undefined || mxsd !== undefined) {\n    // a. Let mnsd be the result of calling the GetNumberOption abstract\n    //    operation with arguments options, \"minimumSignificantDigits\", 1, 21,\n    //    and 1.\n    mnsd = GetNumberOption(options, 'minimumSignificantDigits', 1, 21, 1); // b. Let mxsd be the result of calling the GetNumberOption abstract\n    //     operation with arguments options, \"maximumSignificantDigits\", mnsd,\n    //     21, and 21.\n\n    mxsd = GetNumberOption(options, 'maximumSignificantDigits', mnsd, 21, 21); // c. Set the [[minimumSignificantDigits]] internal property of numberFormat\n    //    to mnsd, and the [[maximumSignificantDigits]] internal property of\n    //    numberFormat to mxsd.\n\n    internal['[[minimumSignificantDigits]]'] = mnsd;\n    internal['[[maximumSignificantDigits]]'] = mxsd;\n  } // 34. Let g be the result of calling the GetOption abstract operation with the\n  //     arguments options, \"useGrouping\", \"boolean\", undefined, and true.\n\n\n  var g = GetOption(options, 'useGrouping', 'boolean', undefined, true); // 35. Set the [[useGrouping]] internal property of numberFormat to g.\n\n  internal['[[useGrouping]]'] = g; // 36. Let dataLocaleData be the result of calling the [[Get]] internal method of\n  //     localeData with argument dataLocale.\n\n  var dataLocaleData = localeData[dataLocale]; // 37. Let patterns be the result of calling the [[Get]] internal method of\n  //     dataLocaleData with argument \"patterns\".\n\n  var patterns = dataLocaleData.patterns; // 38. Assert: patterns is an object (see 11.2.3)\n  // 39. Let stylePatterns be the result of calling the [[Get]] internal method of\n  //     patterns with argument s.\n\n  var stylePatterns = patterns[s]; // 40. Set the [[positivePattern]] internal property of numberFormat to the\n  //     result of calling the [[Get]] internal method of stylePatterns with the\n  //     argument \"positivePattern\".\n\n  internal['[[positivePattern]]'] = stylePatterns.positivePattern; // 41. Set the [[negativePattern]] internal property of numberFormat to the\n  //     result of calling the [[Get]] internal method of stylePatterns with the\n  //     argument \"negativePattern\".\n\n  internal['[[negativePattern]]'] = stylePatterns.negativePattern; // 42. Set the [[boundFormat]] internal property of numberFormat to undefined.\n\n  internal['[[boundFormat]]'] = undefined; // 43. Set the [[initializedNumberFormat]] internal property of numberFormat to\n  //     true.\n\n  internal['[[initializedNumberFormat]]'] = true; // In ES3, we need to pre-bind the format() function\n\n  if (es3) numberFormat.format = GetFormatNumber.call(numberFormat); // Restore the RegExp properties\n\n  regexpRestore(); // Return the newly initialised object\n\n  return numberFormat;\n}\n\nfunction CurrencyDigits(currency) {\n  // When the CurrencyDigits abstract operation is called with an argument currency\n  // (which must be an upper case String value), the following steps are taken:\n  // 1. If the ISO 4217 currency and funds code list contains currency as an\n  // alphabetic code, then return the minor unit value corresponding to the\n  // currency from the list; else return 2.\n  return currencyMinorUnits[currency] !== undefined ? currencyMinorUnits[currency] : 2;\n}\n/* 11.2.3 */\n\n\ninternals.NumberFormat = {\n  '[[availableLocales]]': [],\n  '[[relevantExtensionKeys]]': ['nu'],\n  '[[localeData]]': {}\n};\n/**\n * When the supportedLocalesOf method of Intl.NumberFormat is called, the\n * following steps are taken:\n */\n\n/* 11.2.2 */\n\ndefineProperty(Intl.NumberFormat, 'supportedLocalesOf', {\n  configurable: true,\n  writable: true,\n  value: fnBind.call(function (locales) {\n    // Bound functions only have the `this` value altered if being used as a constructor,\n    // this lets us imitate a native function that has no constructor\n    if (!hop.call(this, '[[availableLocales]]')) throw new TypeError('supportedLocalesOf() is not a constructor'); // Create an object whose props can be used to restore the values of RegExp props\n\n    var regexpRestore = createRegExpRestore(),\n        // 1. If options is not provided, then let options be undefined.\n    options = arguments[1],\n        // 2. Let availableLocales be the value of the [[availableLocales]] internal\n    //    property of the standard built-in object that is the initial value of\n    //    Intl.NumberFormat.\n    availableLocales = this['[[availableLocales]]'],\n        // 3. Let requestedLocales be the result of calling the CanonicalizeLocaleList\n    //    abstract operation (defined in 9.2.1) with argument locales.\n    requestedLocales = CanonicalizeLocaleList(locales); // Restore the RegExp properties\n\n    regexpRestore(); // 4. Return the result of calling the SupportedLocales abstract operation\n    //    (defined in 9.2.8) with arguments availableLocales, requestedLocales,\n    //    and options.\n\n    return SupportedLocales(availableLocales, requestedLocales, options);\n  }, internals.NumberFormat)\n});\n/**\n * This named accessor property returns a function that formats a number\n * according to the effective locale and the formatting options of this\n * NumberFormat object.\n */\n\n/* 11.3.2 */\n\ndefineProperty(Intl.NumberFormat.prototype, 'format', {\n  configurable: true,\n  get: GetFormatNumber\n});\n\nfunction GetFormatNumber() {\n  var internal = this !== null && babelHelpers$1[\"typeof\"](this) === 'object' && getInternalProperties(this); // Satisfy test 11.3_b\n\n  if (!internal || !internal['[[initializedNumberFormat]]']) throw new TypeError('`this` value for format() is not an initialized Intl.NumberFormat object.'); // The value of the [[Get]] attribute is a function that takes the following\n  // steps:\n  // 1. If the [[boundFormat]] internal property of this NumberFormat object\n  //    is undefined, then:\n\n  if (internal['[[boundFormat]]'] === undefined) {\n    // a. Let F be a Function object, with internal properties set as\n    //    specified for built-in functions in ES5, 15, or successor, and the\n    //    length property set to 1, that takes the argument value and\n    //    performs the following steps:\n    var F = function F(value) {\n      // i. If value is not provided, then let value be undefined.\n      // ii. Let x be ToNumber(value).\n      // iii. Return the result of calling the FormatNumber abstract\n      //      operation (defined below) with arguments this and x.\n      return FormatNumber(this,\n      /* x = */\n      Number(value));\n    }; // b. Let bind be the standard built-in function object defined in ES5,\n    //    15.3.4.5.\n    // c. Let bf be the result of calling the [[Call]] internal method of\n    //    bind with F as the this value and an argument list containing\n    //    the single item this.\n\n\n    var bf = fnBind.call(F, this); // d. Set the [[boundFormat]] internal property of this NumberFormat\n    //    object to bf.\n\n    internal['[[boundFormat]]'] = bf;\n  } // Return the value of the [[boundFormat]] internal property of this\n  // NumberFormat object.\n\n\n  return internal['[[boundFormat]]'];\n}\n\nfunction formatToParts() {\n  var value = arguments.length <= 0 || arguments[0] === undefined ? undefined : arguments[0];\n  var internal = this !== null && babelHelpers$1[\"typeof\"](this) === 'object' && getInternalProperties(this);\n  if (!internal || !internal['[[initializedNumberFormat]]']) throw new TypeError('`this` value for formatToParts() is not an initialized Intl.NumberFormat object.');\n  var x = Number(value);\n  return FormatNumberToParts(this, x);\n}\n\nObject.defineProperty(Intl.NumberFormat.prototype, 'formatToParts', {\n  configurable: true,\n  enumerable: false,\n  writable: true,\n  value: formatToParts\n});\n/*\n * @spec[stasm/ecma402/number-format-to-parts/spec/numberformat.html]\n * @clause[sec-formatnumbertoparts]\n */\n\nfunction FormatNumberToParts(numberFormat, x) {\n  // 1. Let parts be ? PartitionNumberPattern(numberFormat, x).\n  var parts = PartitionNumberPattern(numberFormat, x); // 2. Let result be ArrayCreate(0).\n\n  var result = []; // 3. Let n be 0.\n\n  var n = 0; // 4. For each part in parts, do:\n\n  for (var i = 0; parts.length > i; i++) {\n    var part = parts[i]; // a. Let O be ObjectCreate(%ObjectPrototype%).\n\n    var O = {}; // a. Perform ? CreateDataPropertyOrThrow(O, \"type\", part.[[type]]).\n\n    O.type = part['[[type]]']; // a. Perform ? CreateDataPropertyOrThrow(O, \"value\", part.[[value]]).\n\n    O.value = part['[[value]]']; // a. Perform ? CreateDataPropertyOrThrow(result, ? ToString(n), O).\n\n    result[n] = O; // a. Increment n by 1.\n\n    n += 1;\n  } // 5. Return result.\n\n\n  return result;\n}\n/*\n * @spec[stasm/ecma402/number-format-to-parts/spec/numberformat.html]\n * @clause[sec-partitionnumberpattern]\n */\n\n\nfunction PartitionNumberPattern(numberFormat, x) {\n  var internal = getInternalProperties(numberFormat),\n      locale = internal['[[dataLocale]]'],\n      nums = internal['[[numberingSystem]]'],\n      data = internals.NumberFormat['[[localeData]]'][locale],\n      ild = data.symbols[nums] || data.symbols.latn,\n      pattern = void 0; // 1. If x is not NaN and x < 0, then:\n\n  if (!isNaN(x) && x < 0) {\n    // a. Let x be -x.\n    x = -x; // a. Let pattern be the value of numberFormat.[[negativePattern]].\n\n    pattern = internal['[[negativePattern]]'];\n  } // 2. Else,\n  else {\n      // a. Let pattern be the value of numberFormat.[[positivePattern]].\n      pattern = internal['[[positivePattern]]'];\n    } // 3. Let result be a new empty List.\n\n\n  var result = new List(); // 4. Let beginIndex be Call(%StringProto_indexOf%, pattern, \"{\", 0).\n\n  var beginIndex = pattern.indexOf('{', 0); // 5. Let endIndex be 0.\n\n  var endIndex = 0; // 6. Let nextIndex be 0.\n\n  var nextIndex = 0; // 7. Let length be the number of code units in pattern.\n\n  var length = pattern.length; // 8. Repeat while beginIndex is an integer index into pattern:\n\n  while (beginIndex > -1 && beginIndex < length) {\n    // a. Set endIndex to Call(%StringProto_indexOf%, pattern, \"}\", beginIndex)\n    endIndex = pattern.indexOf('}', beginIndex); // a. If endIndex = -1, throw new Error exception.\n\n    if (endIndex === -1) throw new Error(); // a. If beginIndex is greater than nextIndex, then:\n\n    if (beginIndex > nextIndex) {\n      // i. Let literal be a substring of pattern from position nextIndex, inclusive, to position beginIndex, exclusive.\n      var literal = pattern.substring(nextIndex, beginIndex); // ii. Add new part record { [[type]]: \"literal\", [[value]]: literal } as a new element of the list result.\n\n      arrPush.call(result, {\n        '[[type]]': 'literal',\n        '[[value]]': literal\n      });\n    } // a. Let p be the substring of pattern from position beginIndex, exclusive, to position endIndex, exclusive.\n\n\n    var p = pattern.substring(beginIndex + 1, endIndex); // a. If p is equal \"number\", then:\n\n    if (p === \"number\") {\n      // i. If x is NaN,\n      if (isNaN(x)) {\n        // 1. Let n be an ILD String value indicating the NaN value.\n        var n = ild.nan; // 2. Add new part record { [[type]]: \"nan\", [[value]]: n } as a new element of the list result.\n\n        arrPush.call(result, {\n          '[[type]]': 'nan',\n          '[[value]]': n\n        });\n      } // ii. Else if isFinite(x) is false,\n      else if (!isFinite(x)) {\n          // 1. Let n be an ILD String value indicating infinity.\n          var _n = ild.infinity; // 2. Add new part record { [[type]]: \"infinity\", [[value]]: n } as a new element of the list result.\n\n          arrPush.call(result, {\n            '[[type]]': 'infinity',\n            '[[value]]': _n\n          });\n        } // iii. Else,\n        else {\n            // 1. If the value of numberFormat.[[style]] is \"percent\" and isFinite(x), let x be 100 × x.\n            if (internal['[[style]]'] === 'percent' && isFinite(x)) x *= 100;\n\n            var _n2 = void 0; // 2. If the numberFormat.[[minimumSignificantDigits]] and numberFormat.[[maximumSignificantDigits]] are present, then\n\n\n            if (hop.call(internal, '[[minimumSignificantDigits]]') && hop.call(internal, '[[maximumSignificantDigits]]')) {\n              // a. Let n be ToRawPrecision(x, numberFormat.[[minimumSignificantDigits]], numberFormat.[[maximumSignificantDigits]]).\n              _n2 = ToRawPrecision(x, internal['[[minimumSignificantDigits]]'], internal['[[maximumSignificantDigits]]']);\n            } // 3. Else,\n            else {\n                // a. Let n be ToRawFixed(x, numberFormat.[[minimumIntegerDigits]], numberFormat.[[minimumFractionDigits]], numberFormat.[[maximumFractionDigits]]).\n                _n2 = ToRawFixed(x, internal['[[minimumIntegerDigits]]'], internal['[[minimumFractionDigits]]'], internal['[[maximumFractionDigits]]']);\n              } // 4. If the value of the numberFormat.[[numberingSystem]] matches one of the values in the \"Numbering System\" column of Table 2 below, then\n\n\n            if (numSys[nums]) {\n              (function () {\n                // a. Let digits be an array whose 10 String valued elements are the UTF-16 string representations of the 10 digits specified in the \"Digits\" column of the matching row in Table 2.\n                var digits = numSys[nums]; // a. Replace each digit in n with the value of digits[digit].\n\n                _n2 = String(_n2).replace(/\\d/g, function (digit) {\n                  return digits[digit];\n                });\n              })();\n            } // 5. Else use an implementation dependent algorithm to map n to the appropriate representation of n in the given numbering system.\n            else _n2 = String(_n2); // ###TODO###\n\n\n            var integer = void 0;\n            var fraction = void 0; // 6. Let decimalSepIndex be Call(%StringProto_indexOf%, n, \".\", 0).\n\n            var decimalSepIndex = _n2.indexOf('.', 0); // 7. If decimalSepIndex > 0, then:\n\n\n            if (decimalSepIndex > 0) {\n              // a. Let integer be the substring of n from position 0, inclusive, to position decimalSepIndex, exclusive.\n              integer = _n2.substring(0, decimalSepIndex); // a. Let fraction be the substring of n from position decimalSepIndex, exclusive, to the end of n.\n\n              fraction = _n2.substring(decimalSepIndex + 1, decimalSepIndex.length);\n            } // 8. Else:\n            else {\n                // a. Let integer be n.\n                integer = _n2; // a. Let fraction be undefined.\n\n                fraction = undefined;\n              } // 9. If the value of the numberFormat.[[useGrouping]] is true,\n\n\n            if (internal['[[useGrouping]]'] === true) {\n              // a. Let groupSepSymbol be the ILND String representing the grouping separator.\n              var groupSepSymbol = ild.group; // a. Let groups be a List whose elements are, in left to right order, the substrings defined by ILND set of locations within the integer.\n\n              var groups = []; // ----> implementation:\n              // Primary group represents the group closest to the decimal\n\n              var pgSize = data.patterns.primaryGroupSize || 3; // Secondary group is every other group\n\n              var sgSize = data.patterns.secondaryGroupSize || pgSize; // Group only if necessary\n\n              if (integer.length > pgSize) {\n                // Index of the primary grouping separator\n                var end = integer.length - pgSize; // Starting index for our loop\n\n                var idx = end % sgSize;\n                var start = integer.slice(0, idx);\n                if (start.length) arrPush.call(groups, start); // Loop to separate into secondary grouping digits\n\n                while (idx < end) {\n                  arrPush.call(groups, integer.slice(idx, idx + sgSize));\n                  idx += sgSize;\n                } // Add the primary grouping digits\n\n\n                arrPush.call(groups, integer.slice(end));\n              } else {\n                arrPush.call(groups, integer);\n              } // a. Assert: The number of elements in groups List is greater than 0.\n\n\n              if (groups.length === 0) throw new Error(); // a. Repeat, while groups List is not empty:\n\n              while (groups.length) {\n                // i. Remove the first element from groups and let integerGroup be the value of that element.\n                var integerGroup = arrShift.call(groups); // ii. Add new part record { [[type]]: \"integer\", [[value]]: integerGroup } as a new element of the list result.\n\n                arrPush.call(result, {\n                  '[[type]]': 'integer',\n                  '[[value]]': integerGroup\n                }); // iii. If groups List is not empty, then:\n\n                if (groups.length) {\n                  // 1. Add new part record { [[type]]: \"group\", [[value]]: groupSepSymbol } as a new element of the list result.\n                  arrPush.call(result, {\n                    '[[type]]': 'group',\n                    '[[value]]': groupSepSymbol\n                  });\n                }\n              }\n            } // 10. Else,\n            else {\n                // a. Add new part record { [[type]]: \"integer\", [[value]]: integer } as a new element of the list result.\n                arrPush.call(result, {\n                  '[[type]]': 'integer',\n                  '[[value]]': integer\n                });\n              } // 11. If fraction is not undefined, then:\n\n\n            if (fraction !== undefined) {\n              // a. Let decimalSepSymbol be the ILND String representing the decimal separator.\n              var decimalSepSymbol = ild.decimal; // a. Add new part record { [[type]]: \"decimal\", [[value]]: decimalSepSymbol } as a new element of the list result.\n\n              arrPush.call(result, {\n                '[[type]]': 'decimal',\n                '[[value]]': decimalSepSymbol\n              }); // a. Add new part record { [[type]]: \"fraction\", [[value]]: fraction } as a new element of the list result.\n\n              arrPush.call(result, {\n                '[[type]]': 'fraction',\n                '[[value]]': fraction\n              });\n            }\n          }\n    } // a. Else if p is equal \"plusSign\", then:\n    else if (p === \"plusSign\") {\n        // i. Let plusSignSymbol be the ILND String representing the plus sign.\n        var plusSignSymbol = ild.plusSign; // ii. Add new part record { [[type]]: \"plusSign\", [[value]]: plusSignSymbol } as a new element of the list result.\n\n        arrPush.call(result, {\n          '[[type]]': 'plusSign',\n          '[[value]]': plusSignSymbol\n        });\n      } // a. Else if p is equal \"minusSign\", then:\n      else if (p === \"minusSign\") {\n          // i. Let minusSignSymbol be the ILND String representing the minus sign.\n          var minusSignSymbol = ild.minusSign; // ii. Add new part record { [[type]]: \"minusSign\", [[value]]: minusSignSymbol } as a new element of the list result.\n\n          arrPush.call(result, {\n            '[[type]]': 'minusSign',\n            '[[value]]': minusSignSymbol\n          });\n        } // a. Else if p is equal \"percentSign\" and numberFormat.[[style]] is \"percent\", then:\n        else if (p === \"percentSign\" && internal['[[style]]'] === \"percent\") {\n            // i. Let percentSignSymbol be the ILND String representing the percent sign.\n            var percentSignSymbol = ild.percentSign; // ii. Add new part record { [[type]]: \"percentSign\", [[value]]: percentSignSymbol } as a new element of the list result.\n\n            arrPush.call(result, {\n              '[[type]]': 'literal',\n              '[[value]]': percentSignSymbol\n            });\n          } // a. Else if p is equal \"currency\" and numberFormat.[[style]] is \"currency\", then:\n          else if (p === \"currency\" && internal['[[style]]'] === \"currency\") {\n              // i. Let currency be the value of numberFormat.[[currency]].\n              var currency = internal['[[currency]]'];\n              var cd = void 0; // ii. If numberFormat.[[currencyDisplay]] is \"code\", then\n\n              if (internal['[[currencyDisplay]]'] === \"code\") {\n                // 1. Let cd be currency.\n                cd = currency;\n              } // iii. Else if numberFormat.[[currencyDisplay]] is \"symbol\", then\n              else if (internal['[[currencyDisplay]]'] === \"symbol\") {\n                  // 1. Let cd be an ILD string representing currency in short form. If the implementation does not have such a representation of currency, use currency itself.\n                  cd = data.currencies[currency] || currency;\n                } // iv. Else if numberFormat.[[currencyDisplay]] is \"name\", then\n                else if (internal['[[currencyDisplay]]'] === \"name\") {\n                    // 1. Let cd be an ILD string representing currency in long form. If the implementation does not have such a representation of currency, then use currency itself.\n                    cd = currency;\n                  } // v. Add new part record { [[type]]: \"currency\", [[value]]: cd } as a new element of the list result.\n\n\n              arrPush.call(result, {\n                '[[type]]': 'currency',\n                '[[value]]': cd\n              });\n            } // a. Else,\n            else {\n                // i. Let literal be the substring of pattern from position beginIndex, inclusive, to position endIndex, inclusive.\n                var _literal = pattern.substring(beginIndex, endIndex); // ii. Add new part record { [[type]]: \"literal\", [[value]]: literal } as a new element of the list result.\n\n\n                arrPush.call(result, {\n                  '[[type]]': 'literal',\n                  '[[value]]': _literal\n                });\n              } // a. Set nextIndex to endIndex + 1.\n\n\n    nextIndex = endIndex + 1; // a. Set beginIndex to Call(%StringProto_indexOf%, pattern, \"{\", nextIndex)\n\n    beginIndex = pattern.indexOf('{', nextIndex);\n  } // 9. If nextIndex is less than length, then:\n\n\n  if (nextIndex < length) {\n    // a. Let literal be the substring of pattern from position nextIndex, inclusive, to position length, exclusive.\n    var _literal2 = pattern.substring(nextIndex, length); // a. Add new part record { [[type]]: \"literal\", [[value]]: literal } as a new element of the list result.\n\n\n    arrPush.call(result, {\n      '[[type]]': 'literal',\n      '[[value]]': _literal2\n    });\n  } // 10. Return result.\n\n\n  return result;\n}\n/*\n * @spec[stasm/ecma402/number-format-to-parts/spec/numberformat.html]\n * @clause[sec-formatnumber]\n */\n\n\nfunction FormatNumber(numberFormat, x) {\n  // 1. Let parts be ? PartitionNumberPattern(numberFormat, x).\n  var parts = PartitionNumberPattern(numberFormat, x); // 2. Let result be an empty String.\n\n  var result = ''; // 3. For each part in parts, do:\n\n  for (var i = 0; parts.length > i; i++) {\n    var part = parts[i]; // a. Set result to a String value produced by concatenating result and part.[[value]].\n\n    result += part['[[value]]'];\n  } // 4. Return result.\n\n\n  return result;\n}\n/**\n * When the ToRawPrecision abstract operation is called with arguments x (which\n * must be a finite non-negative number), minPrecision, and maxPrecision (both\n * must be integers between 1 and 21) the following steps are taken:\n */\n\n\nfunction ToRawPrecision(x, minPrecision, maxPrecision) {\n  // 1. Let p be maxPrecision.\n  var p = maxPrecision;\n  var m = void 0,\n      e = void 0; // 2. If x = 0, then\n\n  if (x === 0) {\n    // a. Let m be the String consisting of p occurrences of the character \"0\".\n    m = arrJoin.call(Array(p + 1), '0'); // b. Let e be 0.\n\n    e = 0;\n  } // 3. Else\n  else {\n      // a. Let e and n be integers such that 10ᵖ⁻¹ ≤ n < 10ᵖ and for which the\n      //    exact mathematical value of n × 10ᵉ⁻ᵖ⁺¹ – x is as close to zero as\n      //    possible. If there are two such sets of e and n, pick the e and n for\n      //    which n × 10ᵉ⁻ᵖ⁺¹ is larger.\n      e = log10Floor(Math.abs(x)); // Easier to get to m from here\n\n      var f = Math.round(Math.exp(Math.abs(e - p + 1) * Math.LN10)); // b. Let m be the String consisting of the digits of the decimal\n      //    representation of n (in order, with no leading zeroes)\n\n      m = String(Math.round(e - p + 1 < 0 ? x * f : x / f));\n    } // 4. If e ≥ p, then\n\n\n  if (e >= p) // a. Return the concatenation of m and e-p+1 occurrences of the character \"0\".\n    return m + arrJoin.call(Array(e - p + 1 + 1), '0'); // 5. If e = p-1, then\n  else if (e === p - 1) // a. Return m.\n      return m; // 6. If e ≥ 0, then\n    else if (e >= 0) // a. Let m be the concatenation of the first e+1 characters of m, the character\n        //    \".\", and the remaining p–(e+1) characters of m.\n        m = m.slice(0, e + 1) + '.' + m.slice(e + 1); // 7. If e < 0, then\n      else if (e < 0) // a. Let m be the concatenation of the String \"0.\", –(e+1) occurrences of the\n          //    character \"0\", and the string m.\n          m = '0.' + arrJoin.call(Array(-(e + 1) + 1), '0') + m; // 8. If m contains the character \".\", and maxPrecision > minPrecision, then\n\n  if (m.indexOf(\".\") >= 0 && maxPrecision > minPrecision) {\n    // a. Let cut be maxPrecision – minPrecision.\n    var cut = maxPrecision - minPrecision; // b. Repeat while cut > 0 and the last character of m is \"0\":\n\n    while (cut > 0 && m.charAt(m.length - 1) === '0') {\n      //  i. Remove the last character from m.\n      m = m.slice(0, -1); //  ii. Decrease cut by 1.\n\n      cut--;\n    } // c. If the last character of m is \".\", then\n\n\n    if (m.charAt(m.length - 1) === '.') //    i. Remove the last character from m.\n      m = m.slice(0, -1);\n  } // 9. Return m.\n\n\n  return m;\n}\n/**\n * @spec[tc39/ecma402/master/spec/numberformat.html]\n * @clause[sec-torawfixed]\n * When the ToRawFixed abstract operation is called with arguments x (which must\n * be a finite non-negative number), minInteger (which must be an integer between\n * 1 and 21), minFraction, and maxFraction (which must be integers between 0 and\n * 20) the following steps are taken:\n */\n\n\nfunction ToRawFixed(x, minInteger, minFraction, maxFraction) {\n  // 1. Let f be maxFraction.\n  var f = maxFraction; // 2. Let n be an integer for which the exact mathematical value of n ÷ 10f – x is as close to zero as possible. If there are two such n, pick the larger n.\n\n  var n = Math.pow(10, f) * x; // diverging...\n  // 3. If n = 0, let m be the String \"0\". Otherwise, let m be the String consisting of the digits of the decimal representation of n (in order, with no leading zeroes).\n\n  var m = n === 0 ? \"0\" : n.toFixed(0); // divering...\n\n  {\n    // this diversion is needed to take into consideration big numbers, e.g.:\n    // 1.2344501e+37 -> 12344501000000000000000000000000000000\n    var idx = void 0;\n    var exp = (idx = m.indexOf('e')) > -1 ? m.slice(idx + 1) : 0;\n\n    if (exp) {\n      m = m.slice(0, idx).replace('.', '');\n      m += arrJoin.call(Array(exp - (m.length - 1) + 1), '0');\n    }\n  }\n\n  var _int = void 0; // 4. If f ≠ 0, then\n\n\n  if (f !== 0) {\n    // a. Let k be the number of characters in m.\n    var k = m.length; // a. If k ≤ f, then\n\n    if (k <= f) {\n      // i. Let z be the String consisting of f+1–k occurrences of the character \"0\".\n      var z = arrJoin.call(Array(f + 1 - k + 1), '0'); // ii. Let m be the concatenation of Strings z and m.\n\n      m = z + m; // iii. Let k be f+1.\n\n      k = f + 1;\n    } // a. Let a be the first k–f characters of m, and let b be the remaining f characters of m.\n\n\n    var a = m.substring(0, k - f),\n        b = m.substring(k - f, m.length); // a. Let m be the concatenation of the three Strings a, \".\", and b.\n\n    m = a + \".\" + b; // a. Let int be the number of characters in a.\n\n    _int = a.length;\n  } // 5. Else, let int be the number of characters in m.\n  else _int = m.length; // 6. Let cut be maxFraction – minFraction.\n\n\n  var cut = maxFraction - minFraction; // 7. Repeat while cut > 0 and the last character of m is \"0\":\n\n  while (cut > 0 && m.slice(-1) === \"0\") {\n    // a. Remove the last character from m.\n    m = m.slice(0, -1); // a. Decrease cut by 1.\n\n    cut--;\n  } // 8. If the last character of m is \".\", then\n\n\n  if (m.slice(-1) === \".\") {\n    // a. Remove the last character from m.\n    m = m.slice(0, -1);\n  } // 9. If int < minInteger, then\n\n\n  if (_int < minInteger) {\n    // a. Let z be the String consisting of minInteger–int occurrences of the character \"0\".\n    var _z = arrJoin.call(Array(minInteger - _int + 1), '0'); // a. Let m be the concatenation of Strings z and m.\n\n\n    m = _z + m;\n  } // 10. Return m.\n\n\n  return m;\n} // Sect 11.3.2 Table 2, Numbering systems\n// ======================================\n\n\nvar numSys = {\n  arab: [\"٠\", \"١\", \"٢\", \"٣\", \"٤\", \"٥\", \"٦\", \"٧\", \"٨\", \"٩\"],\n  arabext: [\"۰\", \"۱\", \"۲\", \"۳\", \"۴\", \"۵\", \"۶\", \"۷\", \"۸\", \"۹\"],\n  bali: [\"᭐\", \"᭑\", \"᭒\", \"᭓\", \"᭔\", \"᭕\", \"᭖\", \"᭗\", \"᭘\", \"᭙\"],\n  beng: [\"০\", \"১\", \"২\", \"৩\", \"৪\", \"৫\", \"৬\", \"৭\", \"৮\", \"৯\"],\n  deva: [\"०\", \"१\", \"२\", \"३\", \"४\", \"५\", \"६\", \"७\", \"८\", \"९\"],\n  fullwide: [\"０\", \"１\", \"２\", \"３\", \"４\", \"５\", \"６\", \"７\", \"８\", \"９\"],\n  gujr: [\"૦\", \"૧\", \"૨\", \"૩\", \"૪\", \"૫\", \"૬\", \"૭\", \"૮\", \"૯\"],\n  guru: [\"੦\", \"੧\", \"੨\", \"੩\", \"੪\", \"੫\", \"੬\", \"੭\", \"੮\", \"੯\"],\n  hanidec: [\"〇\", \"一\", \"二\", \"三\", \"四\", \"五\", \"六\", \"七\", \"八\", \"九\"],\n  khmr: [\"០\", \"១\", \"២\", \"៣\", \"៤\", \"៥\", \"៦\", \"៧\", \"៨\", \"៩\"],\n  knda: [\"೦\", \"೧\", \"೨\", \"೩\", \"೪\", \"೫\", \"೬\", \"೭\", \"೮\", \"೯\"],\n  laoo: [\"໐\", \"໑\", \"໒\", \"໓\", \"໔\", \"໕\", \"໖\", \"໗\", \"໘\", \"໙\"],\n  latn: [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"],\n  limb: [\"᥆\", \"᥇\", \"᥈\", \"᥉\", \"᥊\", \"᥋\", \"᥌\", \"᥍\", \"᥎\", \"᥏\"],\n  mlym: [\"൦\", \"൧\", \"൨\", \"൩\", \"൪\", \"൫\", \"൬\", \"൭\", \"൮\", \"൯\"],\n  mong: [\"᠐\", \"᠑\", \"᠒\", \"᠓\", \"᠔\", \"᠕\", \"᠖\", \"᠗\", \"᠘\", \"᠙\"],\n  mymr: [\"၀\", \"၁\", \"၂\", \"၃\", \"၄\", \"၅\", \"၆\", \"၇\", \"၈\", \"၉\"],\n  orya: [\"୦\", \"୧\", \"୨\", \"୩\", \"୪\", \"୫\", \"୬\", \"୭\", \"୮\", \"୯\"],\n  tamldec: [\"௦\", \"௧\", \"௨\", \"௩\", \"௪\", \"௫\", \"௬\", \"௭\", \"௮\", \"௯\"],\n  telu: [\"౦\", \"౧\", \"౨\", \"౩\", \"౪\", \"౫\", \"౬\", \"౭\", \"౮\", \"౯\"],\n  thai: [\"๐\", \"๑\", \"๒\", \"๓\", \"๔\", \"๕\", \"๖\", \"๗\", \"๘\", \"๙\"],\n  tibt: [\"༠\", \"༡\", \"༢\", \"༣\", \"༤\", \"༥\", \"༦\", \"༧\", \"༨\", \"༩\"]\n};\n/**\n * This function provides access to the locale and formatting options computed\n * during initialization of the object.\n *\n * The function returns a new object whose properties and attributes are set as\n * if constructed by an object literal assigning to each of the following\n * properties the value of the corresponding internal property of this\n * NumberFormat object (see 11.4): locale, numberingSystem, style, currency,\n * currencyDisplay, minimumIntegerDigits, minimumFractionDigits,\n * maximumFractionDigits, minimumSignificantDigits, maximumSignificantDigits, and\n * useGrouping. Properties whose corresponding internal properties are not present\n * are not assigned.\n */\n\n/* 11.3.3 */\n\ndefineProperty(Intl.NumberFormat.prototype, 'resolvedOptions', {\n  configurable: true,\n  writable: true,\n  value: function value() {\n    var prop = void 0,\n        descs = new Record(),\n        props = ['locale', 'numberingSystem', 'style', 'currency', 'currencyDisplay', 'minimumIntegerDigits', 'minimumFractionDigits', 'maximumFractionDigits', 'minimumSignificantDigits', 'maximumSignificantDigits', 'useGrouping'],\n        internal = this !== null && babelHelpers$1[\"typeof\"](this) === 'object' && getInternalProperties(this); // Satisfy test 11.3_b\n\n    if (!internal || !internal['[[initializedNumberFormat]]']) throw new TypeError('`this` value for resolvedOptions() is not an initialized Intl.NumberFormat object.');\n\n    for (var i = 0, max = props.length; i < max; i++) {\n      if (hop.call(internal, prop = '[[' + props[i] + ']]')) descs[props[i]] = {\n        value: internal[prop],\n        writable: true,\n        configurable: true,\n        enumerable: true\n      };\n    }\n\n    return objCreate({}, descs);\n  }\n});\n/* jslint esnext: true */\n// Match these datetime components in a CLDR pattern, except those in single quotes\n\nvar expDTComponents = /(?:[Eec]{1,6}|G{1,5}|[Qq]{1,5}|(?:[yYur]+|U{1,5})|[ML]{1,5}|d{1,2}|D{1,3}|F{1}|[abB]{1,5}|[hkHK]{1,2}|w{1,2}|W{1}|m{1,2}|s{1,2}|[zZOvVxX]{1,4})(?=([^']*'[^']*')*[^']*$)/g; // trim patterns after transformations\n\nvar expPatternTrimmer = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g; // Skip over patterns with these datetime components because we don't have data\n// to back them up:\n// timezone, weekday, amoung others\n\nvar unwantedDTCs = /[rqQASjJgwWIQq]/; // xXVO were removed from this list in favor of computing matches with timeZoneName values but printing as empty string\n\nvar dtKeys = [\"era\", \"year\", \"month\", \"day\", \"weekday\", \"quarter\"];\nvar tmKeys = [\"hour\", \"minute\", \"second\", \"hour12\", \"timeZoneName\"];\n\nfunction isDateFormatOnly(obj) {\n  for (var i = 0; i < tmKeys.length; i += 1) {\n    if (obj.hasOwnProperty(tmKeys[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction isTimeFormatOnly(obj) {\n  for (var i = 0; i < dtKeys.length; i += 1) {\n    if (obj.hasOwnProperty(dtKeys[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction joinDateAndTimeFormats(dateFormatObj, timeFormatObj) {\n  var o = {\n    _: {}\n  };\n\n  for (var i = 0; i < dtKeys.length; i += 1) {\n    if (dateFormatObj[dtKeys[i]]) {\n      o[dtKeys[i]] = dateFormatObj[dtKeys[i]];\n    }\n\n    if (dateFormatObj._[dtKeys[i]]) {\n      o._[dtKeys[i]] = dateFormatObj._[dtKeys[i]];\n    }\n  }\n\n  for (var j = 0; j < tmKeys.length; j += 1) {\n    if (timeFormatObj[tmKeys[j]]) {\n      o[tmKeys[j]] = timeFormatObj[tmKeys[j]];\n    }\n\n    if (timeFormatObj._[tmKeys[j]]) {\n      o._[tmKeys[j]] = timeFormatObj._[tmKeys[j]];\n    }\n  }\n\n  return o;\n}\n\nfunction computeFinalPatterns(formatObj) {\n  // From http://www.unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns:\n  //  'In patterns, two single quotes represents a literal single quote, either\n  //   inside or outside single quotes. Text within single quotes is not\n  //   interpreted in any way (except for two adjacent single quotes).'\n  formatObj.pattern12 = formatObj.extendedPattern.replace(/'([^']*)'/g, function ($0, literal) {\n    return literal ? literal : \"'\";\n  }); // pattern 12 is always the default. we can produce the 24 by removing {ampm}\n\n  formatObj.pattern = formatObj.pattern12.replace('{ampm}', '').replace(expPatternTrimmer, '');\n  return formatObj;\n}\n\nfunction expDTComponentsMeta($0, formatObj) {\n  switch ($0.charAt(0)) {\n    // --- Era\n    case 'G':\n      formatObj.era = ['short', 'short', 'short', 'long', 'narrow'][$0.length - 1];\n      return '{era}';\n    // --- Year\n\n    case 'y':\n    case 'Y':\n    case 'u':\n    case 'U':\n    case 'r':\n      formatObj.year = $0.length === 2 ? '2-digit' : 'numeric';\n      return '{year}';\n    // --- Quarter (not supported in this polyfill)\n\n    case 'Q':\n    case 'q':\n      formatObj.quarter = ['numeric', '2-digit', 'short', 'long', 'narrow'][$0.length - 1];\n      return '{quarter}';\n    // --- Month\n\n    case 'M':\n    case 'L':\n      formatObj.month = ['numeric', '2-digit', 'short', 'long', 'narrow'][$0.length - 1];\n      return '{month}';\n    // --- Week (not supported in this polyfill)\n\n    case 'w':\n      // week of the year\n      formatObj.week = $0.length === 2 ? '2-digit' : 'numeric';\n      return '{weekday}';\n\n    case 'W':\n      // week of the month\n      formatObj.week = 'numeric';\n      return '{weekday}';\n    // --- Day\n\n    case 'd':\n      // day of the month\n      formatObj.day = $0.length === 2 ? '2-digit' : 'numeric';\n      return '{day}';\n\n    case 'D': // day of the year\n\n    case 'F': // day of the week\n\n    case 'g':\n      // 1..n: Modified Julian day\n      formatObj.day = 'numeric';\n      return '{day}';\n    // --- Week Day\n\n    case 'E':\n      // day of the week\n      formatObj.weekday = ['short', 'short', 'short', 'long', 'narrow', 'short'][$0.length - 1];\n      return '{weekday}';\n\n    case 'e':\n      // local day of the week\n      formatObj.weekday = ['numeric', '2-digit', 'short', 'long', 'narrow', 'short'][$0.length - 1];\n      return '{weekday}';\n\n    case 'c':\n      // stand alone local day of the week\n      formatObj.weekday = ['numeric', undefined, 'short', 'long', 'narrow', 'short'][$0.length - 1];\n      return '{weekday}';\n    // --- Period\n\n    case 'a': // AM, PM\n\n    case 'b': // am, pm, noon, midnight\n\n    case 'B':\n      // flexible day periods\n      formatObj.hour12 = true;\n      return '{ampm}';\n    // --- Hour\n\n    case 'h':\n    case 'H':\n      formatObj.hour = $0.length === 2 ? '2-digit' : 'numeric';\n      return '{hour}';\n\n    case 'k':\n    case 'K':\n      formatObj.hour12 = true; // 12-hour-cycle time formats (using h or K)\n\n      formatObj.hour = $0.length === 2 ? '2-digit' : 'numeric';\n      return '{hour}';\n    // --- Minute\n\n    case 'm':\n      formatObj.minute = $0.length === 2 ? '2-digit' : 'numeric';\n      return '{minute}';\n    // --- Second\n\n    case 's':\n      formatObj.second = $0.length === 2 ? '2-digit' : 'numeric';\n      return '{second}';\n\n    case 'S':\n    case 'A':\n      formatObj.second = 'numeric';\n      return '{second}';\n    // --- Timezone\n\n    case 'z': // 1..3, 4: specific non-location format\n\n    case 'Z': // 1..3, 4, 5: The ISO8601 varios formats\n\n    case 'O': // 1, 4: miliseconds in day short, long\n\n    case 'v': // 1, 4: generic non-location format\n\n    case 'V': // 1, 2, 3, 4: time zone ID or city\n\n    case 'X': // 1, 2, 3, 4: The ISO8601 varios formats\n\n    case 'x':\n      // 1, 2, 3, 4: The ISO8601 varios formats\n      // this polyfill only supports much, for now, we are just doing something dummy\n      formatObj.timeZoneName = $0.length < 4 ? 'short' : 'long';\n      return '{timeZoneName}';\n  }\n}\n/**\n * Converts the CLDR availableFormats into the objects and patterns required by\n * the ECMAScript Internationalization API specification.\n */\n\n\nfunction createDateTimeFormat(skeleton, pattern) {\n  // we ignore certain patterns that are unsupported to avoid this expensive op.\n  if (unwantedDTCs.test(pattern)) return undefined;\n  var formatObj = {\n    originalPattern: pattern,\n    _: {}\n  }; // Replace the pattern string with the one required by the specification, whilst\n  // at the same time evaluating it for the subsets and formats\n\n  formatObj.extendedPattern = pattern.replace(expDTComponents, function ($0) {\n    // See which symbol we're dealing with\n    return expDTComponentsMeta($0, formatObj._);\n  }); // Match the skeleton string with the one required by the specification\n  // this implementation is based on the Date Field Symbol Table:\n  // http://unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table\n  // Note: we are adding extra data to the formatObject even though this polyfill\n  //       might not support it.\n\n  skeleton.replace(expDTComponents, function ($0) {\n    // See which symbol we're dealing with\n    return expDTComponentsMeta($0, formatObj);\n  });\n  return computeFinalPatterns(formatObj);\n}\n/**\n * Processes DateTime formats from CLDR to an easier-to-parse format.\n * the result of this operation should be cached the first time a particular\n * calendar is analyzed.\n *\n * The specification requires we support at least the following subsets of\n * date/time components:\n *\n *   - 'weekday', 'year', 'month', 'day', 'hour', 'minute', 'second'\n *   - 'weekday', 'year', 'month', 'day'\n *   - 'year', 'month', 'day'\n *   - 'year', 'month'\n *   - 'month', 'day'\n *   - 'hour', 'minute', 'second'\n *   - 'hour', 'minute'\n *\n * We need to cherry pick at least these subsets from the CLDR data and convert\n * them into the pattern objects used in the ECMA-402 API.\n */\n\n\nfunction createDateTimeFormats(formats) {\n  var availableFormats = formats.availableFormats;\n  var timeFormats = formats.timeFormats;\n  var dateFormats = formats.dateFormats;\n  var result = [];\n  var skeleton = void 0,\n      pattern = void 0,\n      computed = void 0,\n      i = void 0,\n      j = void 0;\n  var timeRelatedFormats = [];\n  var dateRelatedFormats = []; // Map available (custom) formats into a pattern for createDateTimeFormats\n\n  for (skeleton in availableFormats) {\n    if (availableFormats.hasOwnProperty(skeleton)) {\n      pattern = availableFormats[skeleton];\n      computed = createDateTimeFormat(skeleton, pattern);\n\n      if (computed) {\n        result.push(computed); // in some cases, the format is only displaying date specific props\n        // or time specific props, in which case we need to also produce the\n        // combined formats.\n\n        if (isDateFormatOnly(computed)) {\n          dateRelatedFormats.push(computed);\n        } else if (isTimeFormatOnly(computed)) {\n          timeRelatedFormats.push(computed);\n        }\n      }\n    }\n  } // Map time formats into a pattern for createDateTimeFormats\n\n\n  for (skeleton in timeFormats) {\n    if (timeFormats.hasOwnProperty(skeleton)) {\n      pattern = timeFormats[skeleton];\n      computed = createDateTimeFormat(skeleton, pattern);\n\n      if (computed) {\n        result.push(computed);\n        timeRelatedFormats.push(computed);\n      }\n    }\n  } // Map date formats into a pattern for createDateTimeFormats\n\n\n  for (skeleton in dateFormats) {\n    if (dateFormats.hasOwnProperty(skeleton)) {\n      pattern = dateFormats[skeleton];\n      computed = createDateTimeFormat(skeleton, pattern);\n\n      if (computed) {\n        result.push(computed);\n        dateRelatedFormats.push(computed);\n      }\n    }\n  } // combine custom time and custom date formats when they are orthogonals to complete the\n  // formats supported by CLDR.\n  // This Algo is based on section \"Missing Skeleton Fields\" from:\n  // http://unicode.org/reports/tr35/tr35-dates.html#availableFormats_appendItems\n\n\n  for (i = 0; i < timeRelatedFormats.length; i += 1) {\n    for (j = 0; j < dateRelatedFormats.length; j += 1) {\n      if (dateRelatedFormats[j].month === 'long') {\n        pattern = dateRelatedFormats[j].weekday ? formats.full : formats.long;\n      } else if (dateRelatedFormats[j].month === 'short') {\n        pattern = formats.medium;\n      } else {\n        pattern = formats.short;\n      }\n\n      computed = joinDateAndTimeFormats(dateRelatedFormats[j], timeRelatedFormats[i]);\n      computed.originalPattern = pattern;\n      computed.extendedPattern = pattern.replace('{0}', timeRelatedFormats[i].extendedPattern).replace('{1}', dateRelatedFormats[j].extendedPattern).replace(/^[,\\s]+|[,\\s]+$/gi, '');\n      result.push(computeFinalPatterns(computed));\n    }\n  }\n\n  return result;\n} // this represents the exceptions of the rule that are not covered by CLDR availableFormats\n// for single property configurations, they play no role when using multiple properties, and\n// those that are not in this table, are not exceptions or are not covered by the data we\n// provide.\n\n\nvar validSyntheticProps = {\n  second: {\n    numeric: 's',\n    '2-digit': 'ss'\n  },\n  minute: {\n    numeric: 'm',\n    '2-digit': 'mm'\n  },\n  year: {\n    numeric: 'y',\n    '2-digit': 'yy'\n  },\n  day: {\n    numeric: 'd',\n    '2-digit': 'dd'\n  },\n  month: {\n    numeric: 'L',\n    '2-digit': 'LL',\n    narrow: 'LLLLL',\n    short: 'LLL',\n    long: 'LLLL'\n  },\n  weekday: {\n    narrow: 'ccccc',\n    short: 'ccc',\n    long: 'cccc'\n  }\n};\n\nfunction generateSyntheticFormat(propName, propValue) {\n  if (validSyntheticProps[propName] && validSyntheticProps[propName][propValue]) {\n    var _ref2;\n\n    return _ref2 = {\n      originalPattern: validSyntheticProps[propName][propValue],\n      _: defineProperty$1({}, propName, propValue),\n      extendedPattern: \"{\" + propName + \"}\"\n    }, defineProperty$1(_ref2, propName, propValue), defineProperty$1(_ref2, \"pattern12\", \"{\" + propName + \"}\"), defineProperty$1(_ref2, \"pattern\", \"{\" + propName + \"}\"), _ref2;\n  }\n} // An object map of date component keys, saves using a regex later\n\n\nvar dateWidths = objCreate(null, {\n  narrow: {},\n  short: {},\n  long: {}\n});\n/**\n * Returns a string for a date component, resolved using multiple inheritance as specified\n * as specified in the Unicode Technical Standard 35.\n */\n\nfunction resolveDateString(data, ca, component, width, key) {\n  // From http://www.unicode.org/reports/tr35/tr35.html#Multiple_Inheritance:\n  // 'In clearly specified instances, resources may inherit from within the same locale.\n  //  For example, ... the Buddhist calendar inherits from the Gregorian calendar.'\n  var obj = data[ca] && data[ca][component] ? data[ca][component] : data.gregory[component],\n      // \"sideways\" inheritance resolves strings when a key doesn't exist\n  alts = {\n    narrow: ['short', 'long'],\n    short: ['long', 'narrow'],\n    long: ['short', 'narrow']\n  },\n      //\n  resolved = hop.call(obj, width) ? obj[width] : hop.call(obj, alts[width][0]) ? obj[alts[width][0]] : obj[alts[width][1]]; // `key` wouldn't be specified for components 'dayPeriods'\n\n  return key !== null ? resolved[key] : resolved;\n} // Define the DateTimeFormat constructor internally so it cannot be tainted\n\n\nfunction DateTimeFormatConstructor() {\n  var locales = arguments[0];\n  var options = arguments[1];\n\n  if (!this || this === Intl) {\n    return new Intl.DateTimeFormat(locales, options);\n  }\n\n  return InitializeDateTimeFormat(toObject(this), locales, options);\n}\n\ndefineProperty(Intl, 'DateTimeFormat', {\n  configurable: true,\n  writable: true,\n  value: DateTimeFormatConstructor\n}); // Must explicitly set prototypes as unwritable\n\ndefineProperty(DateTimeFormatConstructor, 'prototype', {\n  writable: false\n});\n/**\n * The abstract operation InitializeDateTimeFormat accepts the arguments dateTimeFormat\n * (which must be an object), locales, and options. It initializes dateTimeFormat as a\n * DateTimeFormat object.\n */\n\nfunction\n/* 12.1.1.1 */\nInitializeDateTimeFormat(dateTimeFormat, locales, options) {\n  // This will be a internal properties object if we're not already initialized\n  var internal = getInternalProperties(dateTimeFormat); // Create an object whose props can be used to restore the values of RegExp props\n\n  var regexpRestore = createRegExpRestore(); // 1. If dateTimeFormat has an [[initializedIntlObject]] internal property with\n  //    value true, throw a TypeError exception.\n\n  if (internal['[[initializedIntlObject]]'] === true) throw new TypeError('`this` object has already been initialized as an Intl object'); // Need this to access the `internal` object\n\n  defineProperty(dateTimeFormat, '__getInternalProperties', {\n    value: function value() {\n      // NOTE: Non-standard, for internal use only\n      if (arguments[0] === secret) return internal;\n    }\n  }); // 2. Set the [[initializedIntlObject]] internal property of numberFormat to true.\n\n  internal['[[initializedIntlObject]]'] = true; // 3. Let requestedLocales be the result of calling the CanonicalizeLocaleList\n  //    abstract operation (defined in 9.2.1) with argument locales.\n\n  var requestedLocales = CanonicalizeLocaleList(locales); // 4. Let options be the result of calling the ToDateTimeOptions abstract\n  //    operation (defined below) with arguments options, \"any\", and \"date\".\n\n  options = ToDateTimeOptions(options, 'any', 'date'); // 5. Let opt be a new Record.\n\n  var opt = new Record(); // 6. Let matcher be the result of calling the GetOption abstract operation\n  //    (defined in 9.2.9) with arguments options, \"localeMatcher\", \"string\", a List\n  //    containing the two String values \"lookup\" and \"best fit\", and \"best fit\".\n\n  var matcher = GetOption(options, 'localeMatcher', 'string', new List('lookup', 'best fit'), 'best fit'); // 7. Set opt.[[localeMatcher]] to matcher.\n\n  opt['[[localeMatcher]]'] = matcher; // 8. Let DateTimeFormat be the standard built-in object that is the initial\n  //    value of Intl.DateTimeFormat.\n\n  var DateTimeFormat = internals.DateTimeFormat; // This is what we *really* need\n  // 9. Let localeData be the value of the [[localeData]] internal property of\n  //    DateTimeFormat.\n\n  var localeData = DateTimeFormat['[[localeData]]']; // 10. Let r be the result of calling the ResolveLocale abstract operation\n  //     (defined in 9.2.5) with the [[availableLocales]] internal property of\n  //      DateTimeFormat, requestedLocales, opt, the [[relevantExtensionKeys]]\n  //      internal property of DateTimeFormat, and localeData.\n\n  var r = ResolveLocale(DateTimeFormat['[[availableLocales]]'], requestedLocales, opt, DateTimeFormat['[[relevantExtensionKeys]]'], localeData); // 11. Set the [[locale]] internal property of dateTimeFormat to the value of\n  //     r.[[locale]].\n\n  internal['[[locale]]'] = r['[[locale]]']; // 12. Set the [[calendar]] internal property of dateTimeFormat to the value of\n  //     r.[[ca]].\n\n  internal['[[calendar]]'] = r['[[ca]]']; // 13. Set the [[numberingSystem]] internal property of dateTimeFormat to the value of\n  //     r.[[nu]].\n\n  internal['[[numberingSystem]]'] = r['[[nu]]']; // The specification doesn't tell us to do this, but it's helpful later on\n\n  internal['[[dataLocale]]'] = r['[[dataLocale]]']; // 14. Let dataLocale be the value of r.[[dataLocale]].\n\n  var dataLocale = r['[[dataLocale]]']; // 15. Let tz be the result of calling the [[Get]] internal method of options with\n  //     argument \"timeZone\".\n\n  var tz = options.timeZone; // 16. If tz is not undefined, then\n\n  if (tz !== undefined) {\n    // a. Let tz be ToString(tz).\n    // b. Convert tz to upper case as described in 6.1.\n    //    NOTE: If an implementation accepts additional time zone values, as permitted\n    //          under certain conditions by the Conformance clause, different casing\n    //          rules apply.\n    tz = toLatinUpperCase(tz); // c. If tz is not \"UTC\", then throw a RangeError exception.\n    // ###TODO: accept more time zones###\n\n    if (tz !== 'UTC') throw new RangeError('timeZone is not supported.');\n  } // 17. Set the [[timeZone]] internal property of dateTimeFormat to tz.\n\n\n  internal['[[timeZone]]'] = tz; // 18. Let opt be a new Record.\n\n  opt = new Record(); // 19. For each row of Table 3, except the header row, do:\n\n  for (var prop in dateTimeComponents) {\n    if (!hop.call(dateTimeComponents, prop)) continue; // 20. Let prop be the name given in the Property column of the row.\n    // 21. Let value be the result of calling the GetOption abstract operation,\n    //     passing as argument options, the name given in the Property column of the\n    //     row, \"string\", a List containing the strings given in the Values column of\n    //     the row, and undefined.\n\n    var value = GetOption(options, prop, 'string', dateTimeComponents[prop]); // 22. Set opt.[[<prop>]] to value.\n\n    opt['[[' + prop + ']]'] = value;\n  } // Assigned a value below\n\n\n  var bestFormat = void 0; // 23. Let dataLocaleData be the result of calling the [[Get]] internal method of\n  //     localeData with argument dataLocale.\n\n  var dataLocaleData = localeData[dataLocale]; // 24. Let formats be the result of calling the [[Get]] internal method of\n  //     dataLocaleData with argument \"formats\".\n  //     Note: we process the CLDR formats into the spec'd structure\n\n  var formats = ToDateTimeFormats(dataLocaleData.formats); // 25. Let matcher be the result of calling the GetOption abstract operation with\n  //     arguments options, \"formatMatcher\", \"string\", a List containing the two String\n  //     values \"basic\" and \"best fit\", and \"best fit\".\n\n  matcher = GetOption(options, 'formatMatcher', 'string', new List('basic', 'best fit'), 'best fit'); // Optimization: caching the processed formats as a one time operation by\n  // replacing the initial structure from localeData\n\n  dataLocaleData.formats = formats; // 26. If matcher is \"basic\", then\n\n  if (matcher === 'basic') {\n    // 27. Let bestFormat be the result of calling the BasicFormatMatcher abstract\n    //     operation (defined below) with opt and formats.\n    bestFormat = BasicFormatMatcher(opt, formats); // 28. Else\n  } else {\n    {\n      // diverging\n      var _hr = GetOption(options, 'hour12', 'boolean'\n      /*, undefined, undefined*/\n      );\n\n      opt.hour12 = _hr === undefined ? dataLocaleData.hour12 : _hr;\n    } // 29. Let bestFormat be the result of calling the BestFitFormatMatcher\n    //     abstract operation (defined below) with opt and formats.\n\n    bestFormat = BestFitFormatMatcher(opt, formats);\n  } // 30. For each row in Table 3, except the header row, do\n\n\n  for (var _prop in dateTimeComponents) {\n    if (!hop.call(dateTimeComponents, _prop)) continue; // a. Let prop be the name given in the Property column of the row.\n    // b. Let pDesc be the result of calling the [[GetOwnProperty]] internal method of\n    //    bestFormat with argument prop.\n    // c. If pDesc is not undefined, then\n\n    if (hop.call(bestFormat, _prop)) {\n      // i. Let p be the result of calling the [[Get]] internal method of bestFormat\n      //    with argument prop.\n      var p = bestFormat[_prop];\n      {\n        // diverging\n        p = bestFormat._ && hop.call(bestFormat._, _prop) ? bestFormat._[_prop] : p;\n      } // ii. Set the [[<prop>]] internal property of dateTimeFormat to p.\n\n      internal['[[' + _prop + ']]'] = p;\n    }\n  }\n\n  var pattern = void 0; // Assigned a value below\n  // 31. Let hr12 be the result of calling the GetOption abstract operation with\n  //     arguments options, \"hour12\", \"boolean\", undefined, and undefined.\n\n  var hr12 = GetOption(options, 'hour12', 'boolean'\n  /*, undefined, undefined*/\n  ); // 32. If dateTimeFormat has an internal property [[hour]], then\n\n  if (internal['[[hour]]']) {\n    // a. If hr12 is undefined, then let hr12 be the result of calling the [[Get]]\n    //    internal method of dataLocaleData with argument \"hour12\".\n    hr12 = hr12 === undefined ? dataLocaleData.hour12 : hr12; // b. Set the [[hour12]] internal property of dateTimeFormat to hr12.\n\n    internal['[[hour12]]'] = hr12; // c. If hr12 is true, then\n\n    if (hr12 === true) {\n      // i. Let hourNo0 be the result of calling the [[Get]] internal method of\n      //    dataLocaleData with argument \"hourNo0\".\n      var hourNo0 = dataLocaleData.hourNo0; // ii. Set the [[hourNo0]] internal property of dateTimeFormat to hourNo0.\n\n      internal['[[hourNo0]]'] = hourNo0; // iii. Let pattern be the result of calling the [[Get]] internal method of\n      //      bestFormat with argument \"pattern12\".\n\n      pattern = bestFormat.pattern12;\n    } // d. Else\n    else // i. Let pattern be the result of calling the [[Get]] internal method of\n      //    bestFormat with argument \"pattern\".\n      pattern = bestFormat.pattern;\n  } // 33. Else\n  else // a. Let pattern be the result of calling the [[Get]] internal method of\n    //    bestFormat with argument \"pattern\".\n    pattern = bestFormat.pattern; // 34. Set the [[pattern]] internal property of dateTimeFormat to pattern.\n\n\n  internal['[[pattern]]'] = pattern; // 35. Set the [[boundFormat]] internal property of dateTimeFormat to undefined.\n\n  internal['[[boundFormat]]'] = undefined; // 36. Set the [[initializedDateTimeFormat]] internal property of dateTimeFormat to\n  //     true.\n\n  internal['[[initializedDateTimeFormat]]'] = true; // In ES3, we need to pre-bind the format() function\n\n  if (es3) dateTimeFormat.format = GetFormatDateTime.call(dateTimeFormat); // Restore the RegExp properties\n\n  regexpRestore(); // Return the newly initialised object\n\n  return dateTimeFormat;\n}\n/**\n * Several DateTimeFormat algorithms use values from the following table, which provides\n * property names and allowable values for the components of date and time formats:\n */\n\n\nvar dateTimeComponents = {\n  weekday: [\"narrow\", \"short\", \"long\"],\n  era: [\"narrow\", \"short\", \"long\"],\n  year: [\"2-digit\", \"numeric\"],\n  month: [\"2-digit\", \"numeric\", \"narrow\", \"short\", \"long\"],\n  day: [\"2-digit\", \"numeric\"],\n  hour: [\"2-digit\", \"numeric\"],\n  minute: [\"2-digit\", \"numeric\"],\n  second: [\"2-digit\", \"numeric\"],\n  timeZoneName: [\"short\", \"long\"]\n};\n/**\n * When the ToDateTimeOptions abstract operation is called with arguments options,\n * required, and defaults, the following steps are taken:\n */\n\nfunction ToDateTimeFormats(formats) {\n  if (Object.prototype.toString.call(formats) === '[object Array]') {\n    return formats;\n  }\n\n  return createDateTimeFormats(formats);\n}\n/**\n * When the ToDateTimeOptions abstract operation is called with arguments options,\n * required, and defaults, the following steps are taken:\n */\n\n\nfunction ToDateTimeOptions(options, required, defaults) {\n  // 1. If options is undefined, then let options be null, else let options be\n  //    ToObject(options).\n  if (options === undefined) options = null;else {\n    // (#12) options needs to be a Record, but it also needs to inherit properties\n    var opt2 = toObject(options);\n    options = new Record();\n\n    for (var k in opt2) {\n      options[k] = opt2[k];\n    }\n  } // 2. Let create be the standard built-in function object defined in ES5, 15.2.3.5.\n\n  var create = objCreate; // 3. Let options be the result of calling the [[Call]] internal method of create with\n  //    undefined as the this value and an argument list containing the single item\n  //    options.\n\n  options = create(options); // 4. Let needDefaults be true.\n\n  var needDefaults = true; // 5. If required is \"date\" or \"any\", then\n\n  if (required === 'date' || required === 'any') {\n    // a. For each of the property names \"weekday\", \"year\", \"month\", \"day\":\n    // i. If the result of calling the [[Get]] internal method of options with the\n    //    property name is not undefined, then let needDefaults be false.\n    if (options.weekday !== undefined || options.year !== undefined || options.month !== undefined || options.day !== undefined) needDefaults = false;\n  } // 6. If required is \"time\" or \"any\", then\n\n\n  if (required === 'time' || required === 'any') {\n    // a. For each of the property names \"hour\", \"minute\", \"second\":\n    // i. If the result of calling the [[Get]] internal method of options with the\n    //    property name is not undefined, then let needDefaults be false.\n    if (options.hour !== undefined || options.minute !== undefined || options.second !== undefined) needDefaults = false;\n  } // 7. If needDefaults is true and defaults is either \"date\" or \"all\", then\n\n\n  if (needDefaults && (defaults === 'date' || defaults === 'all')) // a. For each of the property names \"year\", \"month\", \"day\":\n    // i. Call the [[DefineOwnProperty]] internal method of options with the\n    //    property name, Property Descriptor {[[Value]]: \"numeric\", [[Writable]]:\n    //    true, [[Enumerable]]: true, [[Configurable]]: true}, and false.\n    options.year = options.month = options.day = 'numeric'; // 8. If needDefaults is true and defaults is either \"time\" or \"all\", then\n\n  if (needDefaults && (defaults === 'time' || defaults === 'all')) // a. For each of the property names \"hour\", \"minute\", \"second\":\n    // i. Call the [[DefineOwnProperty]] internal method of options with the\n    //    property name, Property Descriptor {[[Value]]: \"numeric\", [[Writable]]:\n    //    true, [[Enumerable]]: true, [[Configurable]]: true}, and false.\n    options.hour = options.minute = options.second = 'numeric'; // 9. Return options.\n\n  return options;\n}\n/**\n * When the BasicFormatMatcher abstract operation is called with two arguments options and\n * formats, the following steps are taken:\n */\n\n\nfunction BasicFormatMatcher(options, formats) {\n  // 1. Let removalPenalty be 120.\n  var removalPenalty = 120; // 2. Let additionPenalty be 20.\n\n  var additionPenalty = 20; // 3. Let longLessPenalty be 8.\n\n  var longLessPenalty = 8; // 4. Let longMorePenalty be 6.\n\n  var longMorePenalty = 6; // 5. Let shortLessPenalty be 6.\n\n  var shortLessPenalty = 6; // 6. Let shortMorePenalty be 3.\n\n  var shortMorePenalty = 3; // 7. Let bestScore be -Infinity.\n\n  var bestScore = -Infinity; // 8. Let bestFormat be undefined.\n\n  var bestFormat = void 0; // 9. Let i be 0.\n\n  var i = 0; // 10. Assert: formats is an Array object.\n  // 11. Let len be the result of calling the [[Get]] internal method of formats with argument \"length\".\n\n  var len = formats.length; // 12. Repeat while i < len:\n\n  while (i < len) {\n    // a. Let format be the result of calling the [[Get]] internal method of formats with argument ToString(i).\n    var format = formats[i]; // b. Let score be 0.\n\n    var score = 0; // c. For each property shown in Table 3:\n\n    for (var property in dateTimeComponents) {\n      if (!hop.call(dateTimeComponents, property)) continue; // i. Let optionsProp be options.[[<property>]].\n\n      var optionsProp = options['[[' + property + ']]']; // ii. Let formatPropDesc be the result of calling the [[GetOwnProperty]] internal method of format\n      //     with argument property.\n      // iii. If formatPropDesc is not undefined, then\n      //     1. Let formatProp be the result of calling the [[Get]] internal method of format with argument property.\n\n      var formatProp = hop.call(format, property) ? format[property] : undefined; // iv. If optionsProp is undefined and formatProp is not undefined, then decrease score by\n      //     additionPenalty.\n\n      if (optionsProp === undefined && formatProp !== undefined) score -= additionPenalty; // v. Else if optionsProp is not undefined and formatProp is undefined, then decrease score by\n      //    removalPenalty.\n      else if (optionsProp !== undefined && formatProp === undefined) score -= removalPenalty; // vi. Else\n        else {\n            // 1. Let values be the array [\"2-digit\", \"numeric\", \"narrow\", \"short\",\n            //    \"long\"].\n            var values = ['2-digit', 'numeric', 'narrow', 'short', 'long']; // 2. Let optionsPropIndex be the index of optionsProp within values.\n\n            var optionsPropIndex = arrIndexOf.call(values, optionsProp); // 3. Let formatPropIndex be the index of formatProp within values.\n\n            var formatPropIndex = arrIndexOf.call(values, formatProp); // 4. Let delta be max(min(formatPropIndex - optionsPropIndex, 2), -2).\n\n            var delta = Math.max(Math.min(formatPropIndex - optionsPropIndex, 2), -2); // 5. If delta = 2, decrease score by longMorePenalty.\n\n            if (delta === 2) score -= longMorePenalty; // 6. Else if delta = 1, decrease score by shortMorePenalty.\n            else if (delta === 1) score -= shortMorePenalty; // 7. Else if delta = -1, decrease score by shortLessPenalty.\n              else if (delta === -1) score -= shortLessPenalty; // 8. Else if delta = -2, decrease score by longLessPenalty.\n                else if (delta === -2) score -= longLessPenalty;\n          }\n    } // d. If score > bestScore, then\n\n\n    if (score > bestScore) {\n      // i. Let bestScore be score.\n      bestScore = score; // ii. Let bestFormat be format.\n\n      bestFormat = format;\n    } // e. Increase i by 1.\n\n\n    i++;\n  } // 13. Return bestFormat.\n\n\n  return bestFormat;\n}\n/**\n * When the BestFitFormatMatcher abstract operation is called with two arguments options\n * and formats, it performs implementation dependent steps, which should return a set of\n * component representations that a typical user of the selected locale would perceive as\n * at least as good as the one returned by BasicFormatMatcher.\n *\n * This polyfill defines the algorithm to be the same as BasicFormatMatcher,\n * with the addition of bonus points awarded where the requested format is of\n * the same data type as the potentially matching format.\n *\n * This algo relies on the concept of closest distance matching described here:\n * http://unicode.org/reports/tr35/tr35-dates.html#Matching_Skeletons\n * Typically a “best match” is found using a closest distance match, such as:\n *\n * Symbols requesting a best choice for the locale are replaced.\n *      j → one of {H, k, h, K}; C → one of {a, b, B}\n * -> Covered by cldr.js matching process\n *\n * For fields with symbols representing the same type (year, month, day, etc):\n *     Most symbols have a small distance from each other.\n *         M ≅ L; E ≅ c; a ≅ b ≅ B; H ≅ k ≅ h ≅ K; ...\n *     -> Covered by cldr.js matching process\n *\n *     Width differences among fields, other than those marking text vs numeric, are given small distance from each other.\n *         MMM ≅ MMMM\n *         MM ≅ M\n *     Numeric and text fields are given a larger distance from each other.\n *         MMM ≈ MM\n *     Symbols representing substantial differences (week of year vs week of month) are given much larger a distances from each other.\n *         d ≋ D; ...\n *     Missing or extra fields cause a match to fail. (But see Missing Skeleton Fields).\n *\n *\n * For example,\n *\n *     { month: 'numeric', day: 'numeric' }\n *\n * should match\n *\n *     { month: '2-digit', day: '2-digit' }\n *\n * rather than\n *\n *     { month: 'short', day: 'numeric' }\n *\n * This makes sense because a user requesting a formatted date with numeric parts would\n * not expect to see the returned format containing narrow, short or long part names\n */\n\n\nfunction BestFitFormatMatcher(options, formats) {\n  /** Diverging: this block implements the hack for single property configuration, eg.:\n   *\n   *      `new Intl.DateTimeFormat('en', {day: 'numeric'})`\n   *\n   * should produce a single digit with the day of the month. This is needed because\n   * CLDR `availableFormats` data structure doesn't cover these cases.\n   */\n  {\n    var optionsPropNames = [];\n\n    for (var property in dateTimeComponents) {\n      if (!hop.call(dateTimeComponents, property)) continue;\n\n      if (options['[[' + property + ']]'] !== undefined) {\n        optionsPropNames.push(property);\n      }\n    }\n\n    if (optionsPropNames.length === 1) {\n      var _bestFormat = generateSyntheticFormat(optionsPropNames[0], options['[[' + optionsPropNames[0] + ']]']);\n\n      if (_bestFormat) {\n        return _bestFormat;\n      }\n    }\n  } // 1. Let removalPenalty be 120.\n\n  var removalPenalty = 120; // 2. Let additionPenalty be 20.\n\n  var additionPenalty = 20; // 3. Let longLessPenalty be 8.\n\n  var longLessPenalty = 8; // 4. Let longMorePenalty be 6.\n\n  var longMorePenalty = 6; // 5. Let shortLessPenalty be 6.\n\n  var shortLessPenalty = 6; // 6. Let shortMorePenalty be 3.\n\n  var shortMorePenalty = 3;\n  var patternPenalty = 2;\n  var hour12Penalty = 1; // 7. Let bestScore be -Infinity.\n\n  var bestScore = -Infinity; // 8. Let bestFormat be undefined.\n\n  var bestFormat = void 0; // 9. Let i be 0.\n\n  var i = 0; // 10. Assert: formats is an Array object.\n  // 11. Let len be the result of calling the [[Get]] internal method of formats with argument \"length\".\n\n  var len = formats.length; // 12. Repeat while i < len:\n\n  while (i < len) {\n    // a. Let format be the result of calling the [[Get]] internal method of formats with argument ToString(i).\n    var format = formats[i]; // b. Let score be 0.\n\n    var score = 0; // c. For each property shown in Table 3:\n\n    for (var _property in dateTimeComponents) {\n      if (!hop.call(dateTimeComponents, _property)) continue; // i. Let optionsProp be options.[[<property>]].\n\n      var optionsProp = options['[[' + _property + ']]']; // ii. Let formatPropDesc be the result of calling the [[GetOwnProperty]] internal method of format\n      //     with argument property.\n      // iii. If formatPropDesc is not undefined, then\n      //     1. Let formatProp be the result of calling the [[Get]] internal method of format with argument property.\n\n      var formatProp = hop.call(format, _property) ? format[_property] : undefined; // Diverging: using the default properties produced by the pattern/skeleton\n      // to match it with user options, and apply a penalty\n\n      var patternProp = hop.call(format._, _property) ? format._[_property] : undefined;\n\n      if (optionsProp !== patternProp) {\n        score -= patternPenalty;\n      } // iv. If optionsProp is undefined and formatProp is not undefined, then decrease score by\n      //     additionPenalty.\n\n\n      if (optionsProp === undefined && formatProp !== undefined) score -= additionPenalty; // v. Else if optionsProp is not undefined and formatProp is undefined, then decrease score by\n      //    removalPenalty.\n      else if (optionsProp !== undefined && formatProp === undefined) score -= removalPenalty; // vi. Else\n        else {\n            // 1. Let values be the array [\"2-digit\", \"numeric\", \"narrow\", \"short\",\n            //    \"long\"].\n            var values = ['2-digit', 'numeric', 'narrow', 'short', 'long']; // 2. Let optionsPropIndex be the index of optionsProp within values.\n\n            var optionsPropIndex = arrIndexOf.call(values, optionsProp); // 3. Let formatPropIndex be the index of formatProp within values.\n\n            var formatPropIndex = arrIndexOf.call(values, formatProp); // 4. Let delta be max(min(formatPropIndex - optionsPropIndex, 2), -2).\n\n            var delta = Math.max(Math.min(formatPropIndex - optionsPropIndex, 2), -2);\n            {\n              // diverging from spec\n              // When the bestFit argument is true, subtract additional penalty where data types are not the same\n              if (formatPropIndex <= 1 && optionsPropIndex >= 2 || formatPropIndex >= 2 && optionsPropIndex <= 1) {\n                // 5. If delta = 2, decrease score by longMorePenalty.\n                if (delta > 0) score -= longMorePenalty;else if (delta < 0) score -= longLessPenalty;\n              } else {\n                // 5. If delta = 2, decrease score by longMorePenalty.\n                if (delta > 1) score -= shortMorePenalty;else if (delta < -1) score -= shortLessPenalty;\n              }\n            }\n          }\n    }\n\n    {\n      // diverging to also take into consideration differences between 12 or 24 hours\n      // which is special for the best fit only.\n      if (format._.hour12 !== options.hour12) {\n        score -= hour12Penalty;\n      }\n    } // d. If score > bestScore, then\n\n    if (score > bestScore) {\n      // i. Let bestScore be score.\n      bestScore = score; // ii. Let bestFormat be format.\n\n      bestFormat = format;\n    } // e. Increase i by 1.\n\n\n    i++;\n  } // 13. Return bestFormat.\n\n\n  return bestFormat;\n}\n/* 12.2.3 */\n\n\ninternals.DateTimeFormat = {\n  '[[availableLocales]]': [],\n  '[[relevantExtensionKeys]]': ['ca', 'nu'],\n  '[[localeData]]': {}\n};\n/**\n * When the supportedLocalesOf method of Intl.DateTimeFormat is called, the\n * following steps are taken:\n */\n\n/* 12.2.2 */\n\ndefineProperty(Intl.DateTimeFormat, 'supportedLocalesOf', {\n  configurable: true,\n  writable: true,\n  value: fnBind.call(function (locales) {\n    // Bound functions only have the `this` value altered if being used as a constructor,\n    // this lets us imitate a native function that has no constructor\n    if (!hop.call(this, '[[availableLocales]]')) throw new TypeError('supportedLocalesOf() is not a constructor'); // Create an object whose props can be used to restore the values of RegExp props\n\n    var regexpRestore = createRegExpRestore(),\n        // 1. If options is not provided, then let options be undefined.\n    options = arguments[1],\n        // 2. Let availableLocales be the value of the [[availableLocales]] internal\n    //    property of the standard built-in object that is the initial value of\n    //    Intl.NumberFormat.\n    availableLocales = this['[[availableLocales]]'],\n        // 3. Let requestedLocales be the result of calling the CanonicalizeLocaleList\n    //    abstract operation (defined in 9.2.1) with argument locales.\n    requestedLocales = CanonicalizeLocaleList(locales); // Restore the RegExp properties\n\n    regexpRestore(); // 4. Return the result of calling the SupportedLocales abstract operation\n    //    (defined in 9.2.8) with arguments availableLocales, requestedLocales,\n    //    and options.\n\n    return SupportedLocales(availableLocales, requestedLocales, options);\n  }, internals.NumberFormat)\n});\n/**\n * This named accessor property returns a function that formats a number\n * according to the effective locale and the formatting options of this\n * DateTimeFormat object.\n */\n\n/* 12.3.2 */\n\ndefineProperty(Intl.DateTimeFormat.prototype, 'format', {\n  configurable: true,\n  get: GetFormatDateTime\n});\n\nfunction GetFormatDateTime() {\n  var internal = this !== null && babelHelpers$1[\"typeof\"](this) === 'object' && getInternalProperties(this); // Satisfy test 12.3_b\n\n  if (!internal || !internal['[[initializedDateTimeFormat]]']) throw new TypeError('`this` value for format() is not an initialized Intl.DateTimeFormat object.'); // The value of the [[Get]] attribute is a function that takes the following\n  // steps:\n  // 1. If the [[boundFormat]] internal property of this DateTimeFormat object\n  //    is undefined, then:\n\n  if (internal['[[boundFormat]]'] === undefined) {\n    // a. Let F be a Function object, with internal properties set as\n    //    specified for built-in functions in ES5, 15, or successor, and the\n    //    length property set to 0, that takes the argument date and\n    //    performs the following steps:\n    var F = function F() {\n      var date = arguments.length <= 0 || arguments[0] === undefined ? undefined : arguments[0]; //   i. If date is not provided or is undefined, then let x be the\n      //      result as if by the expression Date.now() where Date.now is\n      //      the standard built-in function defined in ES5, 15.9.4.4.\n      //  ii. Else let x be ToNumber(date).\n      // iii. Return the result of calling the FormatDateTime abstract\n      //      operation (defined below) with arguments this and x.\n\n      var x = date === undefined ? Date.now() : toNumber(date);\n      return FormatDateTime(this, x);\n    }; // b. Let bind be the standard built-in function object defined in ES5,\n    //    15.3.4.5.\n    // c. Let bf be the result of calling the [[Call]] internal method of\n    //    bind with F as the this value and an argument list containing\n    //    the single item this.\n\n\n    var bf = fnBind.call(F, this); // d. Set the [[boundFormat]] internal property of this NumberFormat\n    //    object to bf.\n\n    internal['[[boundFormat]]'] = bf;\n  } // Return the value of the [[boundFormat]] internal property of this\n  // NumberFormat object.\n\n\n  return internal['[[boundFormat]]'];\n}\n\nfunction formatToParts$1() {\n  var date = arguments.length <= 0 || arguments[0] === undefined ? undefined : arguments[0];\n  var internal = this !== null && babelHelpers$1[\"typeof\"](this) === 'object' && getInternalProperties(this);\n  if (!internal || !internal['[[initializedDateTimeFormat]]']) throw new TypeError('`this` value for formatToParts() is not an initialized Intl.DateTimeFormat object.');\n  var x = date === undefined ? Date.now() : toNumber(date);\n  return FormatToPartsDateTime(this, x);\n}\n\nObject.defineProperty(Intl.DateTimeFormat.prototype, 'formatToParts', {\n  enumerable: false,\n  writable: true,\n  configurable: true,\n  value: formatToParts$1\n});\n\nfunction CreateDateTimeParts(dateTimeFormat, x) {\n  // 1. If x is not a finite Number, then throw a RangeError exception.\n  if (!isFinite(x)) throw new RangeError('Invalid valid date passed to format');\n\n  var internal = dateTimeFormat.__getInternalProperties(secret); // Creating restore point for properties on the RegExp object... please wait\n\n  /* let regexpRestore = */\n\n\n  createRegExpRestore(); // ###TODO: review this\n  // 2. Let locale be the value of the [[locale]] internal property of dateTimeFormat.\n\n  var locale = internal['[[locale]]']; // 3. Let nf be the result of creating a new NumberFormat object as if by the\n  // expression new Intl.NumberFormat([locale], {useGrouping: false}) where\n  // Intl.NumberFormat is the standard built-in constructor defined in 11.1.3.\n\n  var nf = new Intl.NumberFormat([locale], {\n    useGrouping: false\n  }); // 4. Let nf2 be the result of creating a new NumberFormat object as if by the\n  // expression new Intl.NumberFormat([locale], {minimumIntegerDigits: 2, useGrouping:\n  // false}) where Intl.NumberFormat is the standard built-in constructor defined in\n  // 11.1.3.\n\n  var nf2 = new Intl.NumberFormat([locale], {\n    minimumIntegerDigits: 2,\n    useGrouping: false\n  }); // 5. Let tm be the result of calling the ToLocalTime abstract operation (defined\n  // below) with x, the value of the [[calendar]] internal property of dateTimeFormat,\n  // and the value of the [[timeZone]] internal property of dateTimeFormat.\n\n  var tm = ToLocalTime(x, internal['[[calendar]]'], internal['[[timeZone]]']); // 6. Let result be the value of the [[pattern]] internal property of dateTimeFormat.\n\n  var pattern = internal['[[pattern]]']; // 7.\n\n  var result = new List(); // 8.\n\n  var index = 0; // 9.\n\n  var beginIndex = pattern.indexOf('{'); // 10.\n\n  var endIndex = 0; // Need the locale minus any extensions\n\n  var dataLocale = internal['[[dataLocale]]']; // Need the calendar data from CLDR\n\n  var localeData = internals.DateTimeFormat['[[localeData]]'][dataLocale].calendars;\n  var ca = internal['[[calendar]]']; // 11.\n\n  while (beginIndex !== -1) {\n    var fv = void 0; // a.\n\n    endIndex = pattern.indexOf('}', beginIndex); // b.\n\n    if (endIndex === -1) {\n      throw new Error('Unclosed pattern');\n    } // c.\n\n\n    if (beginIndex > index) {\n      arrPush.call(result, {\n        type: 'literal',\n        value: pattern.substring(index, beginIndex)\n      });\n    } // d.\n\n\n    var p = pattern.substring(beginIndex + 1, endIndex); // e.\n\n    if (dateTimeComponents.hasOwnProperty(p)) {\n      //   i. Let f be the value of the [[<p>]] internal property of dateTimeFormat.\n      var f = internal['[[' + p + ']]']; //  ii. Let v be the value of tm.[[<p>]].\n\n      var v = tm['[[' + p + ']]']; // iii. If p is \"year\" and v ≤ 0, then let v be 1 - v.\n\n      if (p === 'year' && v <= 0) {\n        v = 1 - v;\n      } //  iv. If p is \"month\", then increase v by 1.\n      else if (p === 'month') {\n          v++;\n        } //   v. If p is \"hour\" and the value of the [[hour12]] internal property of\n        //      dateTimeFormat is true, then\n        else if (p === 'hour' && internal['[[hour12]]'] === true) {\n            // 1. Let v be v modulo 12.\n            v = v % 12; // 2. If v is 0 and the value of the [[hourNo0]] internal property of\n            //    dateTimeFormat is true, then let v be 12.\n\n            if (v === 0 && internal['[[hourNo0]]'] === true) {\n              v = 12;\n            }\n          } //  vi. If f is \"numeric\", then\n\n\n      if (f === 'numeric') {\n        // 1. Let fv be the result of calling the FormatNumber abstract operation\n        //    (defined in 11.3.2) with arguments nf and v.\n        fv = FormatNumber(nf, v);\n      } // vii. Else if f is \"2-digit\", then\n      else if (f === '2-digit') {\n          // 1. Let fv be the result of calling the FormatNumber abstract operation\n          //    with arguments nf2 and v.\n          fv = FormatNumber(nf2, v); // 2. If the length of fv is greater than 2, let fv be the substring of fv\n          //    containing the last two characters.\n\n          if (fv.length > 2) {\n            fv = fv.slice(-2);\n          }\n        } // viii. Else if f is \"narrow\", \"short\", or \"long\", then let fv be a String\n        //     value representing f in the desired form; the String value depends upon\n        //     the implementation and the effective locale and calendar of\n        //     dateTimeFormat. If p is \"month\", then the String value may also depend\n        //     on whether dateTimeFormat has a [[day]] internal property. If p is\n        //     \"timeZoneName\", then the String value may also depend on the value of\n        //     the [[inDST]] field of tm.\n        else if (f in dateWidths) {\n            switch (p) {\n              case 'month':\n                fv = resolveDateString(localeData, ca, 'months', f, tm['[[' + p + ']]']);\n                break;\n\n              case 'weekday':\n                try {\n                  fv = resolveDateString(localeData, ca, 'days', f, tm['[[' + p + ']]']); // fv = resolveDateString(ca.days, f)[tm['[['+ p +']]']];\n                } catch (e) {\n                  throw new Error('Could not find weekday data for locale ' + locale);\n                }\n\n                break;\n\n              case 'timeZoneName':\n                fv = ''; // ###TODO\n\n                break;\n\n              case 'era':\n                try {\n                  fv = resolveDateString(localeData, ca, 'eras', f, tm['[[' + p + ']]']);\n                } catch (e) {\n                  throw new Error('Could not find era data for locale ' + locale);\n                }\n\n                break;\n\n              default:\n                fv = tm['[[' + p + ']]'];\n            }\n          } // ix\n\n\n      arrPush.call(result, {\n        type: p,\n        value: fv\n      }); // f.\n    } else if (p === 'ampm') {\n      // i.\n      var _v = tm['[[hour]]']; // ii./iii.\n\n      fv = resolveDateString(localeData, ca, 'dayPeriods', _v > 11 ? 'pm' : 'am', null); // iv.\n\n      arrPush.call(result, {\n        type: 'dayPeriod',\n        value: fv\n      }); // g.\n    } else {\n      arrPush.call(result, {\n        type: 'literal',\n        value: pattern.substring(beginIndex, endIndex + 1)\n      });\n    } // h.\n\n\n    index = endIndex + 1; // i.\n\n    beginIndex = pattern.indexOf('{', index);\n  } // 12.\n\n\n  if (endIndex < pattern.length - 1) {\n    arrPush.call(result, {\n      type: 'literal',\n      value: pattern.substr(endIndex + 1)\n    });\n  } // 13.\n\n\n  return result;\n}\n/**\n * When the FormatDateTime abstract operation is called with arguments dateTimeFormat\n * (which must be an object initialized as a DateTimeFormat) and x (which must be a Number\n * value), it returns a String value representing x (interpreted as a time value as\n * specified in ES5, 15.9.1.1) according to the effective locale and the formatting\n * options of dateTimeFormat.\n */\n\n\nfunction FormatDateTime(dateTimeFormat, x) {\n  var parts = CreateDateTimeParts(dateTimeFormat, x);\n  var result = '';\n\n  for (var i = 0; parts.length > i; i++) {\n    var part = parts[i];\n    result += part.value;\n  }\n\n  return result;\n}\n\nfunction FormatToPartsDateTime(dateTimeFormat, x) {\n  var parts = CreateDateTimeParts(dateTimeFormat, x);\n  var result = [];\n\n  for (var i = 0; parts.length > i; i++) {\n    var part = parts[i];\n    result.push({\n      type: part.type,\n      value: part.value\n    });\n  }\n\n  return result;\n}\n/**\n * When the ToLocalTime abstract operation is called with arguments date, calendar, and\n * timeZone, the following steps are taken:\n */\n\n\nfunction ToLocalTime(date, calendar, timeZone) {\n  // 1. Apply calendrical calculations on date for the given calendar and time zone to\n  //    produce weekday, era, year, month, day, hour, minute, second, and inDST values.\n  //    The calculations should use best available information about the specified\n  //    calendar and time zone. If the calendar is \"gregory\", then the calculations must\n  //    match the algorithms specified in ES5, 15.9.1, except that calculations are not\n  //    bound by the restrictions on the use of best available information on time zones\n  //    for local time zone adjustment and daylight saving time adjustment imposed by\n  //    ES5, 15.9.1.7 and 15.9.1.8.\n  // ###TODO###\n  var d = new Date(date),\n      m = 'get' + (timeZone || ''); // 2. Return a Record with fields [[weekday]], [[era]], [[year]], [[month]], [[day]],\n  //    [[hour]], [[minute]], [[second]], and [[inDST]], each with the corresponding\n  //    calculated value.\n\n  return new Record({\n    '[[weekday]]': d[m + 'Day'](),\n    '[[era]]': +(d[m + 'FullYear']() >= 0),\n    '[[year]]': d[m + 'FullYear'](),\n    '[[month]]': d[m + 'Month'](),\n    '[[day]]': d[m + 'Date'](),\n    '[[hour]]': d[m + 'Hours'](),\n    '[[minute]]': d[m + 'Minutes'](),\n    '[[second]]': d[m + 'Seconds'](),\n    '[[inDST]]': false // ###TODO###\n\n  });\n}\n/**\n * The function returns a new object whose properties and attributes are set as if\n * constructed by an object literal assigning to each of the following properties the\n * value of the corresponding internal property of this DateTimeFormat object (see 12.4):\n * locale, calendar, numberingSystem, timeZone, hour12, weekday, era, year, month, day,\n * hour, minute, second, and timeZoneName. Properties whose corresponding internal\n * properties are not present are not assigned.\n */\n\n/* 12.3.3 */\n\n\ndefineProperty(Intl.DateTimeFormat.prototype, 'resolvedOptions', {\n  writable: true,\n  configurable: true,\n  value: function value() {\n    var prop = void 0,\n        descs = new Record(),\n        props = ['locale', 'calendar', 'numberingSystem', 'timeZone', 'hour12', 'weekday', 'era', 'year', 'month', 'day', 'hour', 'minute', 'second', 'timeZoneName'],\n        internal = this !== null && babelHelpers$1[\"typeof\"](this) === 'object' && getInternalProperties(this); // Satisfy test 12.3_b\n\n    if (!internal || !internal['[[initializedDateTimeFormat]]']) throw new TypeError('`this` value for resolvedOptions() is not an initialized Intl.DateTimeFormat object.');\n\n    for (var i = 0, max = props.length; i < max; i++) {\n      if (hop.call(internal, prop = '[[' + props[i] + ']]')) descs[props[i]] = {\n        value: internal[prop],\n        writable: true,\n        configurable: true,\n        enumerable: true\n      };\n    }\n\n    return objCreate({}, descs);\n  }\n});\nvar ls = Intl.__localeSensitiveProtos = {\n  Number: {},\n  Date: {}\n};\n/**\n * When the toLocaleString method is called with optional arguments locales and options,\n * the following steps are taken:\n */\n\n/* 13.2.1 */\n\nls.Number.toLocaleString = function () {\n  // Satisfy test 13.2.1_1\n  if (Object.prototype.toString.call(this) !== '[object Number]') throw new TypeError('`this` value must be a number for Number.prototype.toLocaleString()'); // 1. Let x be this Number value (as defined in ES5, 15.7.4).\n  // 2. If locales is not provided, then let locales be undefined.\n  // 3. If options is not provided, then let options be undefined.\n  // 4. Let numberFormat be the result of creating a new object as if by the\n  //    expression new Intl.NumberFormat(locales, options) where\n  //    Intl.NumberFormat is the standard built-in constructor defined in 11.1.3.\n  // 5. Return the result of calling the FormatNumber abstract operation\n  //    (defined in 11.3.2) with arguments numberFormat and x.\n\n  return FormatNumber(new NumberFormatConstructor(arguments[0], arguments[1]), this);\n};\n/**\n * When the toLocaleString method is called with optional arguments locales and options,\n * the following steps are taken:\n */\n\n/* 13.3.1 */\n\n\nls.Date.toLocaleString = function () {\n  // Satisfy test 13.3.0_1\n  if (Object.prototype.toString.call(this) !== '[object Date]') throw new TypeError('`this` value must be a Date instance for Date.prototype.toLocaleString()'); // 1. Let x be this time value (as defined in ES5, 15.9.5).\n\n  var x = +this; // 2. If x is NaN, then return \"Invalid Date\".\n\n  if (isNaN(x)) return 'Invalid Date'; // 3. If locales is not provided, then let locales be undefined.\n\n  var locales = arguments[0]; // 4. If options is not provided, then let options be undefined.\n\n  var options = arguments[1]; // 5. Let options be the result of calling the ToDateTimeOptions abstract\n  //    operation (defined in 12.1.1) with arguments options, \"any\", and \"all\".\n\n  options = ToDateTimeOptions(options, 'any', 'all'); // 6. Let dateTimeFormat be the result of creating a new object as if by the\n  //    expression new Intl.DateTimeFormat(locales, options) where\n  //    Intl.DateTimeFormat is the standard built-in constructor defined in 12.1.3.\n\n  var dateTimeFormat = new DateTimeFormatConstructor(locales, options); // 7. Return the result of calling the FormatDateTime abstract operation (defined\n  //    in 12.3.2) with arguments dateTimeFormat and x.\n\n  return FormatDateTime(dateTimeFormat, x);\n};\n/**\n * When the toLocaleDateString method is called with optional arguments locales and\n * options, the following steps are taken:\n */\n\n/* 13.3.2 */\n\n\nls.Date.toLocaleDateString = function () {\n  // Satisfy test 13.3.0_1\n  if (Object.prototype.toString.call(this) !== '[object Date]') throw new TypeError('`this` value must be a Date instance for Date.prototype.toLocaleDateString()'); // 1. Let x be this time value (as defined in ES5, 15.9.5).\n\n  var x = +this; // 2. If x is NaN, then return \"Invalid Date\".\n\n  if (isNaN(x)) return 'Invalid Date'; // 3. If locales is not provided, then let locales be undefined.\n\n  var locales = arguments[0],\n      // 4. If options is not provided, then let options be undefined.\n  options = arguments[1]; // 5. Let options be the result of calling the ToDateTimeOptions abstract\n  //    operation (defined in 12.1.1) with arguments options, \"date\", and \"date\".\n\n  options = ToDateTimeOptions(options, 'date', 'date'); // 6. Let dateTimeFormat be the result of creating a new object as if by the\n  //    expression new Intl.DateTimeFormat(locales, options) where\n  //    Intl.DateTimeFormat is the standard built-in constructor defined in 12.1.3.\n\n  var dateTimeFormat = new DateTimeFormatConstructor(locales, options); // 7. Return the result of calling the FormatDateTime abstract operation (defined\n  //    in 12.3.2) with arguments dateTimeFormat and x.\n\n  return FormatDateTime(dateTimeFormat, x);\n};\n/**\n * When the toLocaleTimeString method is called with optional arguments locales and\n * options, the following steps are taken:\n */\n\n/* 13.3.3 */\n\n\nls.Date.toLocaleTimeString = function () {\n  // Satisfy test 13.3.0_1\n  if (Object.prototype.toString.call(this) !== '[object Date]') throw new TypeError('`this` value must be a Date instance for Date.prototype.toLocaleTimeString()'); // 1. Let x be this time value (as defined in ES5, 15.9.5).\n\n  var x = +this; // 2. If x is NaN, then return \"Invalid Date\".\n\n  if (isNaN(x)) return 'Invalid Date'; // 3. If locales is not provided, then let locales be undefined.\n\n  var locales = arguments[0]; // 4. If options is not provided, then let options be undefined.\n\n  var options = arguments[1]; // 5. Let options be the result of calling the ToDateTimeOptions abstract\n  //    operation (defined in 12.1.1) with arguments options, \"time\", and \"time\".\n\n  options = ToDateTimeOptions(options, 'time', 'time'); // 6. Let dateTimeFormat be the result of creating a new object as if by the\n  //    expression new Intl.DateTimeFormat(locales, options) where\n  //    Intl.DateTimeFormat is the standard built-in constructor defined in 12.1.3.\n\n  var dateTimeFormat = new DateTimeFormatConstructor(locales, options); // 7. Return the result of calling the FormatDateTime abstract operation (defined\n  //    in 12.3.2) with arguments dateTimeFormat and x.\n\n  return FormatDateTime(dateTimeFormat, x);\n};\n\ndefineProperty(Intl, '__applyLocaleSensitivePrototypes', {\n  writable: true,\n  configurable: true,\n  value: function value() {\n    defineProperty(Number.prototype, 'toLocaleString', {\n      writable: true,\n      configurable: true,\n      value: ls.Number.toLocaleString\n    }); // Need this here for IE 8, to avoid the _DontEnum_ bug\n\n    defineProperty(Date.prototype, 'toLocaleString', {\n      writable: true,\n      configurable: true,\n      value: ls.Date.toLocaleString\n    });\n\n    for (var k in ls.Date) {\n      if (hop.call(ls.Date, k)) defineProperty(Date.prototype, k, {\n        writable: true,\n        configurable: true,\n        value: ls.Date[k]\n      });\n    }\n  }\n});\n/**\n * Can't really ship a single script with data for hundreds of locales, so we provide\n * this __addLocaleData method as a means for the developer to add the data on an\n * as-needed basis\n */\n\ndefineProperty(Intl, '__addLocaleData', {\n  value: function value(data) {\n    if (!IsStructurallyValidLanguageTag(data.locale)) throw new Error(\"Object passed doesn't identify itself with a valid language tag\");\n    addLocaleData(data, data.locale);\n  }\n});\n\nfunction addLocaleData(data, tag) {\n  // Both NumberFormat and DateTimeFormat require number data, so throw if it isn't present\n  if (!data.number) throw new Error(\"Object passed doesn't contain locale data for Intl.NumberFormat\");\n  var locale = void 0,\n      locales = [tag],\n      parts = tag.split('-'); // Create fallbacks for locale data with scripts, e.g. Latn, Hans, Vaii, etc\n\n  if (parts.length > 2 && parts[1].length === 4) arrPush.call(locales, parts[0] + '-' + parts[2]);\n\n  while (locale = arrShift.call(locales)) {\n    // Add to NumberFormat internal properties as per 11.2.3\n    arrPush.call(internals.NumberFormat['[[availableLocales]]'], locale);\n    internals.NumberFormat['[[localeData]]'][locale] = data.number; // ...and DateTimeFormat internal properties as per 12.2.3\n\n    if (data.date) {\n      data.date.nu = data.number.nu;\n      arrPush.call(internals.DateTimeFormat['[[availableLocales]]'], locale);\n      internals.DateTimeFormat['[[localeData]]'][locale] = data.date;\n    }\n  } // If this is the first set of locale data added, make it the default\n\n\n  if (defaultLocale === undefined) setDefaultLocale(tag);\n}\n\ndefineProperty(Intl, '__disableRegExpRestore', {\n  value: function value() {\n    internals.disableRegExpRestore = true;\n  }\n});\nmodule.exports = Intl;"],"sourceRoot":""}